{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rio is an Application Deployment Engine for Kubernetes that can be layered on top of any standard Kubernetes cluster. Consisting of a few Kubernetes custom resources and a CLI to enhance the user experience, users can easily deploy services to Kubernetes and automatically get continuous delivery, DNS, HTTPS, routing, monitoring, autoscaling, canary deployments, git-triggered builds, and much more. All it takes to get going is an existing Kubernetes cluster and the rio CLI. Rio is currently in Beta. Connect with us on the #rio channel on the rancher slack","title":"Home"},{"location":"api-docs/","text":"Packages: admin.rio.cattle.io/v1 management.cattle.io/v3 rio.cattle.io/v1 admin.rio.cattle.io/v1 Resource Types: ClusterDomain PublicDomain RioInfo SystemStack ClusterDomain Field Description apiVersion string admin.rio.cattle.io/v1 kind string ClusterDomain metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec ClusterDomainSpec secretName string SecretName holding the TLS certificate for this domain. This is expected to be a wildcard certificate httpsPort int The public HTTPS port for the cluster domain httpPort int The public HTTP port for the cluster domain addresses []Address The addresses assigned to the ClusterDomain by the provider status ClusterDomainStatus PublicDomain PublicDomain is a top-level resource which allows a user to access its own public domain for the services inside cluster. It can be pointed to a Router or a Service. It is the user\u2019s responsibility to setup a CNAME or A record to the clusterDomain or ingress IP. Field Description apiVersion string admin.rio.cattle.io/v1 kind string PublicDomain metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec PublicDomainSpec secretName string SecretName holding the TLS certificate for this domain. targetApp string Target App Name. Only TargetAppName or TargetRouter can be set targetRouter string Target Router Name. Only TargetAppName or TargetRouter can be set targetVersion string Target Version targetNamespace string Target Service or Router Namespace status PublicDomainStatus RioInfo Field Description apiVersion string admin.rio.cattle.io/v1 kind string RioInfo metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. status RioInfoStatus SystemStack Field Description apiVersion string admin.rio.cattle.io/v1 kind string SystemStack metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. Address ( Appears on: ClusterDomainSpec ) Field Description ip string hostname string ClusterDomainSpec ( Appears on: ClusterDomain ) Field Description secretName string SecretName holding the TLS certificate for this domain. This is expected to be a wildcard certificate httpsPort int The public HTTPS port for the cluster domain httpPort int The public HTTP port for the cluster domain addresses []Address The addresses assigned to the ClusterDomain by the provider ClusterDomainStatus ( Appears on: ClusterDomain ) Field Description assignedSecretName string httpsSupported bool conditions []github.com/rancher/wrangler/pkg/genericcondition.GenericCondition PublicDomainSpec ( Appears on: PublicDomain ) Field Description secretName string SecretName holding the TLS certificate for this domain. targetApp string Target App Name. Only TargetAppName or TargetRouter can be set targetRouter string Target Router Name. Only TargetAppName or TargetRouter can be set targetVersion string Target Version targetNamespace string Target Service or Router Namespace PublicDomainStatus ( Appears on: PublicDomain ) Field Description httpsSupported bool Whether HTTP is supported in the Domain assignedSecretName string Secret containing TLS cert for HTTPS conditions []github.com/rancher/wrangler/pkg/genericcondition.GenericCondition Represents the latest available observations of a PublicDomain\u2019s current state. RioInfoStatus ( Appears on: RioInfo ) Field Description version string gitCommit string systemNamespace string conditions []github.com/rancher/wrangler/pkg/genericcondition.GenericCondition systemComponentReadyMap map[string]string management.cattle.io/v3 Resource Types: Setting User Setting Field Description apiVersion string management.cattle.io/v3 kind string Setting metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. value string default string customized bool source string User Field Description apiVersion string management.cattle.io/v3 kind string User metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. displayName string description string username string password string mustChangePassword bool principalIds []string me bool enabled bool spec UserSpec status UserStatus UserSpec ( Appears on: User ) UserStatus ( Appears on: User ) Field Description conditions []github.com/rancher/wrangler/pkg/genericcondition.GenericCondition rio.cattle.io/v1 Resource Types: ExternalService Router Service Stack ExternalService ExternalService creates a DNS record and route rules for any Service outside of the cluster, can be IPs or FQDN outside the mesh Field Description apiVersion string rio.cattle.io/v1 kind string ExternalService metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec ExternalServiceSpec ipAddresses []string External service located outside the mesh, represented by IPs fqdn string External service located outside the mesh, represented by DNS targetApp string In-Mesh app in another namespace targetVersion string In-Mesh version in another namespace targetRouter string In-Mesh router in another namespace targetServiceNamespace string Namespace of in-mesh service in another namespace status ExternalServiceStatus Router Router is a top level resource to create L7 routing to different services. It will create VirtualService, ServiceEntry and DestinationRules Field Description apiVersion string rio.cattle.io/v1 kind string Router metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec RouterSpec routes []RouteSpec An ordered list of route rules for HTTP traffic. The first rule matching an incoming request is used. internal bool By default all Routers are public and exposed outside of the cluster. Setting internal to true will cause the Router to not be exposed status RouterStatus Service Service acts as a top level resource for a container and its sidecars and routing resources. Each service represents an individual revision, grouped by Spec.App(defaults to Service.Name), and Spec.Version(defaults to v0) Field Description apiVersion string rio.cattle.io/v1 kind string Service metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec ServiceSpec PodConfig PodConfig template bool This service is a template for new versions to be created based on changes from the build.repo stageOnly bool Whether to only stage services that are generated through the template from build.repo version string Version of this service app string The exposed app name, if no value is set, then metadata.name of the Service is used weight int The weight among services with matching app field to determine how much traffic is load balanced to this service. If rollout is set, the weight becomes the target weight of the rollout. replicas int Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1 in deployment. maxUnavailable k8s.io/apimachinery/pkg/util/intstr.IntOrString (Optional) The maximum number of pods that can be unavailable during the update. The value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). An absolute number is calculated from percentage by rounding down. This cannot be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, the old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. maxSurge k8s.io/apimachinery/pkg/util/intstr.IntOrString (Optional) The maximum number of pods that can be scheduled above the desired number of pods. The value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. An absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once the old pods have been killed, the new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. autoscale AutoscaleConfig Autoscale the replicas based on the amount of traffic received by this service rollout RolloutConfig RolloutConfig controls how each service is allocated ComputedWeight global bool Place one pod per node that matches the scheduling rules serviceMesh bool Whether to disable Service mesh for the Service. If true, no mesh sidecar will be deployed along with the Service requestTimeoutSeconds int RequestTimeoutSeconds specifies the timeout set on api gateway for each individual service permissions []Permission Permissions to the Services. It will create corresponding ServiceAccounts, Roles and RoleBinding. globalPermissions []Permission GlobalPermissions to the Services. It will create corresponding ServiceAccounts, ClusterRoles and ClusterRoleBinding. status ServiceStatus Stack Field Description apiVersion string rio.cattle.io/v1 kind string Stack metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec StackSpec build StackBuild Stack build parameters that watches git repo permissions []Permission Permissions used while deploying objects created by this stack additionalGroupVersionKinds []k8s.io/apimachinery/pkg/runtime/schema.GroupVersionKind Additional GVKs not in the rio.cattle.io that have the rio.cattle.io/stack label. These objects are \u201cowned\u201d by this stack answers map[string]string Stack answers status StackStatus AutoscaleConfig ( Appears on: ServiceSpec ) Field Description concurrency int ContainerConcurrency specifies the maximum allowed in-flight (concurrent) requests per container of the Revision. Defaults to 0 which means unlimited concurrency. minReplicas int32 The minimal number of replicas Service can be scaled maxReplicas int32 The maximum number of replicas Service can be scaled BuildRevision ( Appears on: ServiceStatus ) Field Description commits []string Container ( Appears on: NamedContainer , PodConfig ) Field Description image string Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets. build ImageBuildSpec ImageBuild specifies how to build this image command []string Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell args []string Arguments to the entrypoint. The docker image\u2019s CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell workingDir string Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ports []ContainerPort List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \u201c0.0.0.0\u201d address inside a container will be accessible from the network. Cannot be updated. env []EnvVar List of environment variables to set in the container. Cannot be updated. cpuMillis int64 CPU, in milliCPU (e.g. 500 = .5 CPU cores) memoryBytes int64 Memory, in bytes secrets []DataMount Secrets Mounts configs []DataMount Configmaps Mounts livenessProbe Kubernetes core/v1.Probe Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes readinessProbe Kubernetes core/v1.Probe Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes imagePullPolicy Kubernetes core/v1.PullPolicy Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if tag is does not start with v[0-9] or [0-9], or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images stdin bool Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false. stdinOnce bool Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false tty bool Whether this container should allocate a TTY for itself, also requires \u2018stdin\u2019 to be true. Default is false. volumes []Volume Pod volumes to mount into the container\u2019s filesystem ContainerSecurityContext ContainerSecurityContext ContainerPort ( Appears on: Container ) Field Description name string expose bool Expose will make the port available outside the cluster. All http/https ports will be set to true by default if Expose is nil. All other protocols are set to false by default protocol Protocol port int32 targetPort int32 hostport bool ContainerSecurityContext ( Appears on: Container ) ContainerSecurityContext holds pod-level security attributes and common container constants. Optional: Defaults to empty. See type description for default values of each field. Field Description runAsUser int64 The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container runAsGroup int64 The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. readOnlyRootFilesystem bool Whether this container has a read-only root filesystem. Default is false. privileged bool (Optional) Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. DNS ( Appears on: PodConfig ) Field Description policy Kubernetes core/v1.DNSPolicy Set DNS policy for the pod. Defaults to \u201cClusterFirst\u201d. Valid values are \u2018ClusterFirstWithHostNet\u2019, \u2018ClusterFirst\u2019, \u2018Default\u2019 or \u2018None\u2019. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to \u2018ClusterFirstWithHostNet\u2019. nameservers []string A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed. searches []string A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed. options []PodDNSConfigOption A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy. DataMount ( Appears on: Container ) Field Description target string The directory or file to mount the value to in the container name string The name of the ConfigMap or Secret to mount key string The key in the data of the ConfigMap or Secret to mount to a file. If Key is set the Target must be a file. If key is set the target must be a directory and will contain one file per key from the Secret/ConfigMap data field. Destination ( Appears on: RouteSpec , WeightedDestination ) Field Description app string Destination Service version string Destination Revision port uint32 Destination Port EnvVar ( Appears on: Container ) Field Description name string value string secretName string configMapName string key string ExternalServiceSpec ( Appears on: ExternalService ) Field Description ipAddresses []string External service located outside the mesh, represented by IPs fqdn string External service located outside the mesh, represented by DNS targetApp string In-Mesh app in another namespace targetVersion string In-Mesh version in another namespace targetRouter string In-Mesh router in another namespace targetServiceNamespace string Namespace of in-mesh service in another namespace ExternalServiceStatus ( Appears on: ExternalService ) Field Description conditions []github.com/rancher/wrangler/pkg/genericcondition.GenericCondition Represents the latest available observations of a ExternalService\u2019s current state. Fault ( Appears on: RouteSpec ) Field Description percentage int Percentage of requests on which the delay will be injected. delayMillis int REQUIRED. Add a fixed delay before forwarding the request. Units: milliseconds abortHTTPStatus int Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty. HeaderMatch ( Appears on: Match ) Field Description name string value StringMatch HeaderOperations ( Appears on: RouteSpec ) HeaderOperations Describes the header manipulations to apply Field Description add []NameValue Append the given values to the headers specified by keys (will create a comma-separated list of values) set []NameValue Append the given values to the headers specified by keys (will create a comma-separated list of values) remove []string Remove a the specified headers ImageBuildSpec ( Appears on: Container ) Field Description repo string Repository url revision string Repo Revision. Can be a git commit or tag branch string Repo Branch. If specified, a gitmodule will be created to watch the repo and creating new revision if new commit or tag is pushed. dockerfile string Specify the name of the Dockerfile in the Repo. This is the full path relative to the repo root. Defaults to Dockerfile . context string Specify build context. Defaults to \u201c.\u201d args []string Specify build args template string Specify the build template. Defaults to buildkit . webhookSecretName string Specify the github secret name. Used to create Github webhook, the secret key has to be accessToken cloneSecretName string Specify secret name for checking our git resources pushRegistry string Specify custom registry to push the image instead of built-in one pushRegistrySecretName string Specify secret for pushing to custom registry imageName string Specify image name instead of the one generated from service name, format: $registry/$imageName:$revision pr bool Whether to enable builds for pull requests tag bool Whether to enable builds for tags noCache bool Build image with no cache timeout int TimeoutSeconds describes how long the build can run Match ( Appears on: RouteSpec ) Field Description path StringMatch URI to match values are case-sensitive and formatted as follows: exact: \u201cvalue\u201d for exact string match prefix: \u201cvalue\u201d for prefix-based match regex: \u201cvalue\u201d for ECMAscript style regex-based match methods []string HTTP Method values are case-sensitive and formatted as follows: exact: \u201cvalue\u201d for exact string match prefix: \u201cvalue\u201d for prefix-based match regex: \u201cvalue\u201d for ECMAscript style regex-based match headers []HeaderMatch The header keys must be lowercase and use hyphen as the separator, e.g. x-request-id. Header values are case-sensitive and formatted as follows: exact: \u201cvalue\u201d for exact string match prefix: \u201cvalue\u201d for prefix-based match regex: \u201cvalue\u201d for ECMAscript style regex-based match Note: The keys uri, scheme, method, and authority will be ignored. NameValue ( Appears on: HeaderOperations ) Field Description name string value string NamedContainer ( Appears on: PodConfig ) Field Description name string The name of the container init bool List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ Container Container Permission ( Appears on: ServiceSpec , StackSpec ) Field Description role string verbs []string apiGroup string resource string url string resourceName string PodConfig ( Appears on: ServiceSpec ) Field Description containers []NamedContainer List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated. hostname string Specifies the hostname of the Pod If not specified, the pod\u2019s hostname will be set to a system-defined value. hostAliases []Kubernetes core/v1.HostAlias HostAliases is an optional list of hosts and IPs that will be injected into the pod\u2019s hosts file if specified. This is only valid for non-hostNetwork pods. hostNetwork bool Host networking requested for this pod. Use the host\u2019s network namespace. If this option is set, the ports that will be used must be specified. Default to false. imagePullSecrets []string Image pull secret volumeTemplates []VolumeTemplate Volumes to create per replica dns DNS DNS settings for this Pod Affinity Kubernetes core/v1.Affinity (Members of Affinity are embedded into this type.) Container Container PodDNSConfigOption ( Appears on: DNS ) Field Description name string value string Protocol ( string alias) ( Appears on: ContainerPort ) Question ( Appears on: TemplateMeta ) Field Description variable string The variable name to reference using ${\u2026} syntax label string A friend name for the question description string A longer description of the question type string The field type: string, int, bool, enum. default is string required bool The answer can not be blank default string Default value of the answer if not specified by the user group string Group the question with questions in the same group (Most used by UI) minLength int Minimum length of the answer maxLength int Maximum length of the answer min int Minimum value of an int answer max int Maximum value of an int answer options []string An array of valid answers for type enum questions validChars string Answer must be composed of only these characters invalidChars string Answer must not have any of these characters subquestions []SubQuestion A list of questions that are considered child questions showIf string Ask question only if this evaluates to true, more info on syntax below showSubquestionIf string Ask subquestions if this evaluates to true Redirect ( Appears on: RouteSpec ) Field Description host string path string prefix string toHTTPS bool Retry ( Appears on: RouteSpec ) Field Description timeoutSeconds int attempts int Rewrite ( Appears on: RouteSpec ) Field Description host string path string RolloutConfig ( Appears on: ServiceSpec ) RolloutConfig specifies the configuration when promoting a new revision Field Description increment int Increment Value each Rollout can scale up or down, always a positive number intervalSeconds int Interval between each Rollout in seconds pause bool Pause if true the rollout will stop in place until set to false. RouteSpec ( Appears on: RouterSpec ) Field Description match Match Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed. to []WeightedDestination An http rule can either redirect or forward (default) traffic. The forwarding target can be one of several versions of a service (see glossary in beginning of document). Weights associated with the service version determine the proportion of traffic it receives. redirect Redirect An http rule can either redirect or forward (default) traffic. If traffic passthrough option is specified in the rule, route/redirect will be ignored. The redirect primitive can be used to send a HTTP 301 redirect to a different URI or Authority. rewrite Rewrite Rewrite HTTP URIs and Authority headers. Rewrite cannot be used with Redirect primitive. Rewrite will be performed before forwarding. retry Retry Retries specifies the retry logic for each route headers HeaderOperations Header manipulation rules fault Fault Fault injection policy to apply on HTTP traffic at the client side. Note that timeouts or retries will not be enabled when faults are enabled on the client side. mirror Destination Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination. Mirrored traffic is on a best effort basis where the sidecar/gateway will not wait for the mirrored cluster to respond before returning the response from the original destination. Statistics will be generated for the mirrored destination. timeoutSeconds int TimeoutSeconds specifies timeout setting for each route RouterSpec ( Appears on: Router ) Field Description routes []RouteSpec An ordered list of route rules for HTTP traffic. The first rule matching an incoming request is used. internal bool By default all Routers are public and exposed outside of the cluster. Setting internal to true will cause the Router to not be exposed RouterStatus ( Appears on: Router ) Field Description endpoints []string The endpoint to access the router conditions []github.com/rancher/wrangler/pkg/genericcondition.GenericCondition Represents the latest available observations of a PublicDomain\u2019s current state. ScaleStatus ( Appears on: ServiceStatus ) Field Description unavailable int Total number of unavailable pods targeted by this deployment. This is the total number of pods that are still required for the deployment to have 100% available capacity. They may either be pods that are running but not yet available or pods that still have not been created. available int Total number of available pods (ready for at least minReadySeconds) targeted by this deployment. ServiceSpec ( Appears on: Service ) ServiceSpec represents spec for Service Field Description PodConfig PodConfig template bool This service is a template for new versions to be created based on changes from the build.repo stageOnly bool Whether to only stage services that are generated through the template from build.repo version string Version of this service app string The exposed app name, if no value is set, then metadata.name of the Service is used weight int The weight among services with matching app field to determine how much traffic is load balanced to this service. If rollout is set, the weight becomes the target weight of the rollout. replicas int Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1 in deployment. maxUnavailable k8s.io/apimachinery/pkg/util/intstr.IntOrString (Optional) The maximum number of pods that can be unavailable during the update. The value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). An absolute number is calculated from percentage by rounding down. This cannot be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, the old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. maxSurge k8s.io/apimachinery/pkg/util/intstr.IntOrString (Optional) The maximum number of pods that can be scheduled above the desired number of pods. The value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. An absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once the old pods have been killed, the new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. autoscale AutoscaleConfig Autoscale the replicas based on the amount of traffic received by this service rollout RolloutConfig RolloutConfig controls how each service is allocated ComputedWeight global bool Place one pod per node that matches the scheduling rules serviceMesh bool Whether to disable Service mesh for the Service. If true, no mesh sidecar will be deployed along with the Service requestTimeoutSeconds int RequestTimeoutSeconds specifies the timeout set on api gateway for each individual service permissions []Permission Permissions to the Services. It will create corresponding ServiceAccounts, Roles and RoleBinding. globalPermissions []Permission GlobalPermissions to the Services. It will create corresponding ServiceAccounts, ClusterRoles and ClusterRoleBinding. ServiceStatus ( Appears on: Service ) Field Description deploymentReady bool DeploymentReady for ready status on deployment scaleStatus ScaleStatus ScaleStatus for the Service computedApp string ComputedApp is the calculated value of Spec.App if not set computedVersion string ComputedVersion is the calculated value of Spec.Version if not set computedReplicas int ComputedReplicas is calculated from autoscaling component to make sure pod has the desired load computedWeight int ComputedWeight is the weight calculated from the rollout revision containerRevision map[string]github.com/rancher/rio/pkg/apis/rio.cattle.io/v1.BuildRevision ContainerRevision are populated from builds to store commits for each repo generatedServices map[string]bool GeneratedServices contains all the service names are generated from build template gitCommits []string GitCommits contains all git commits that triggers template update shouldGenerate string ShouldGenerate contains the serviceName that should be generated on the next controller run shouldClean map[string]bool ShouldClean contains all the services that are generated from template but should be cleaned up. conditions []github.com/rancher/wrangler/pkg/genericcondition.GenericCondition Represents the latest available observations of a deployment\u2019s current state. endpoints []string The Endpoints to access this version directly appEndpoints []string The Endpoints to access this service as part of an app buildLogToken string log token to access build log watch bool Watch represents if a service should creates git watcher to watch git changes StackBuild ( Appears on: StackSpec ) Field Description repo string Git repo url branch string Git branch revision string Git revision cloneSecretName string Git secret name for repository rioFile string Specify the name of the Riofile in the Repo. This is the full path relative to the repo root. Defaults to Riofile . webhookSecretName string Specify the github secret name. Used to create Github webhook, the secret key has to be accessToken StackSpec ( Appears on: Stack ) Field Description build StackBuild Stack build parameters that watches git repo permissions []Permission Permissions used while deploying objects created by this stack additionalGroupVersionKinds []k8s.io/apimachinery/pkg/runtime/schema.GroupVersionKind Additional GVKs not in the rio.cattle.io that have the rio.cattle.io/stack label. These objects are \u201cowned\u201d by this stack answers map[string]string Stack answers StackStatus ( Appears on: Stack ) Field Description revision string Observed commit for the build conditions []github.com/rancher/wrangler/pkg/genericcondition.GenericCondition StringMatch ( Appears on: HeaderMatch , Match ) Field Description exact string prefix string regexp string SubQuestion ( Appears on: Question ) Field Description variable string label string description string type string required bool default string group string minLength int maxLength int min int max int options []string validChars string invalidChars string showIf string TemplateMeta Field Description name string version string iconUrl string readme string questions []Question goTemplate bool envSubst bool Volume ( Appears on: Container ) Field Description name string Name is the name of the volume. If multiple Volumes in the same pod share the same name they will be the same underlying storage. If persistent is set to true Name is required and will be used to reference a PersistentVolumeClaim in the current namespace. If Name matches the name of a VolumeTemplate on this service then the VolumeTemplate will be used as the source of the volume. path string That path within the container to mount the volume to hostpath string That path on the host to mount into this container hostPathType Kubernetes core/v1.HostPathType HostPathType specify HostPath type persistent bool If Persistent is true then this volume refers to a PersistentVolumeClaim in this namespace. The Name field is used to reference PersistentVolumeClaim. If the Name of this Volume matches a VolumeTemplate then Persistent is assumed to be true VolumeTemplate ( Appears on: PodConfig ) Field Description labels map[string]string Labels to be applied to the created PVC annotations map[string]string Annotations to be applied to the created PVC Name string Name of the VolumeTemplate. A volume entry will use this name to refer to the created volume accessModes []Kubernetes core/v1.PersistentVolumeAccessMode (Optional) AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage int64 (Optional) Resources represents the minimum resources the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName string Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volumeMode Kubernetes core/v1.PersistentVolumeMode (Optional) volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature. WeightedDestination ( Appears on: RouteSpec ) Field Description Destination Destination weight int Weight for the Destination Generated with gen-crd-api-reference-docs on git commit d9b7db62e .","title":"API Reference"},{"location":"autoscaling/","text":"Autoscaling \u00b6 Rio deploys a simple autoscaler to watch metrics from workloads and scale applications based on current in-flight requests. Note: Metrics are scraped from the linkerd-proxy sidecar, this requires your application to be injected with the linkerd sidecar. This will happen by default when running new workloads. To enable autoscaling: $ rio run --scale 1 -10 -p 8080 strongmonkey1992/autoscale:v0 # to give a higher concurrency $ rio run --scale 1 -10 --concurrency 20 -p 8080 strongmonkey1992/autoscale:v0 # to scale to zero $ rio run --scale 0 -10 -p 8080 strongmonkey1992/autoscale:v0 To test putting load on the service, use hey : hey -z 3m -c 60 http://xxx-xx.xxxxxx.on-rio-io # watch the scale of your service $ watch rio ps Note: concurrency means the maximum in-flight requests each pod can take. If your total in-flight request is 60 and concurrency is 10, Rio will scale workloads to 6 replicas. Note: When scaling an application to zero, the first request will take longer. Troubleshooting \u00b6 Check autoscaler logs for more details on how metrics are collected and scale decision was made. $ rio -s logs autoscaler","title":"Using AutoScaling"},{"location":"autoscaling/#autoscaling","text":"Rio deploys a simple autoscaler to watch metrics from workloads and scale applications based on current in-flight requests. Note: Metrics are scraped from the linkerd-proxy sidecar, this requires your application to be injected with the linkerd sidecar. This will happen by default when running new workloads. To enable autoscaling: $ rio run --scale 1 -10 -p 8080 strongmonkey1992/autoscale:v0 # to give a higher concurrency $ rio run --scale 1 -10 --concurrency 20 -p 8080 strongmonkey1992/autoscale:v0 # to scale to zero $ rio run --scale 0 -10 -p 8080 strongmonkey1992/autoscale:v0 To test putting load on the service, use hey : hey -z 3m -c 60 http://xxx-xx.xxxxxx.on-rio-io # watch the scale of your service $ watch rio ps Note: concurrency means the maximum in-flight requests each pod can take. If your total in-flight request is 60 and concurrency is 10, Rio will scale workloads to 6 replicas. Note: When scaling an application to zero, the first request will take longer.","title":"Autoscaling"},{"location":"autoscaling/#troubleshooting","text":"Check autoscaler logs for more details on how metrics are collected and scale decision was made. $ rio -s logs autoscaler","title":"Troubleshooting"},{"location":"cli-reference/","text":"CLI Reference \u00b6 Table of Contents \u00b6 attach build build-history cat dashboard edit exec export image info inspect install kill logs promote ps router run rm scale stage system-logs system-features uninstall up weight attach \u00b6 Attach to a process running in a container Usage \u00b6 rio attach [ OPTIONS ] CONTAINER Options \u00b6 flag aliases description default --timeout value Timeout waiting for the container to be created to attach to 1m --pod value Specify pod, default is first pod found Examples \u00b6 ```shell script rio attach demo rio attach --timeout 30s --pod mydemopod demo --- ## build Build a docker image using buildkitd ##### Usage rio build command [command options] [arguments...] ##### Options | flag | aliases | description | default | |--------------|---------|-------------------------------------------------------------------------|---------| | -- file value | - f | Name of the file to look for build , support both Riofile and Dockerfile | | | -- tag value | - t | Name and optionally a tag in the 'name:tag' format | | | -- build - arg | | Set build - time variables | | | -- no - cache | | Do not use cache when building the image | | | -- help | - h | show help | | ##### Examples ``` shell script # Navigate to directory with Dockerfile and build it into local registry rio build - t test : v1 # See image that was build rio image # Build from riofile insted rio build - t test : v1 -- no - cache - f Riofile . yaml # Now run the image rio run - n test - p 8080 localhost : 5442 / default / test : v1 # Build the image again with new tag rio build - t test : v2 # Now stage the 2nd image rio stage -- image localhost : 5442 / default / test : v2 test v2 build-history \u00b6 Show previous builds Usage \u00b6 rio build - history [ command options ] [ arguments ...] Options \u00b6 flag aliases description default --quiet -q Only display Names --format value 'json' or 'yaml' or Custom format: '{{.Obj.Name}}' [$FORMAT] Examples \u00b6 ```shell script see previous builds from stacks or workloads \u00b6 rio build-history custom output format \u00b6 rio build-history --format {{.Obj.Name}} --- ## cat Print the contents of a config ##### Usage rio cat [OPTIONS] [NAME...] ##### Options | flag | aliases | description | default | | -------|---------|-------------------------|---------| | --key | -k | The values which to cat | | ##### Examples ``` shell script # cat a configmap rio cat configmap / config - foo # cat a key from a configmap rio cat --key=a configmap/config-foo dashboard \u00b6 Open the dashboard in a browser Usage \u00b6 rio dashboard [ OPTIONS ] Options \u00b6 flag aliases description default --reset-admin Reset admin password Examples \u00b6 ```shell script reset admin pw \u00b6 rio dashboard --reset-admin --- ## edit Edit resources ##### Usage rio edit [TYPE/]RESOURCE_NAME ##### Options | flag | aliases | description | default | |-------|---------|-------------------------------------------------------|---------| | -- raw | | Edit the raw API object , not the pretty formatted one | | ##### Examples ``` shell script rio edit demo @v4 rio edit router / myrouter exec \u00b6 Run a command in a running container Usage \u00b6 rio exec [ OPTIONS ] CONTAINER COMMAND [ ARG... ] Options \u00b6 flag aliases description default --stdin -i Pass stdin to the container --tty -t Stdin is a TTY --container value -c value Specify container in pod, default is first container --pod value Specify pod, default is first pod found Examples \u00b6 ```shell script ssh into running container \u00b6 rio exec -it demo sh this is equivalent of doing \u00b6 rio exec --tty --stdin demo sh choose pod and container \u00b6 rio exec -it --pod mypod --container server demo sh --- ## export Export a namespace or service ##### Usage rio export [TYPE/]NAMESPACE_OR_SERVICE ##### Options | flag | aliases | description | default | |----------------|---------|----------------------------------------------------|---------| | -- format value | | Specify output format , yaml / json . Defaults to yaml | yaml | | -- riofile | | Export riofile format | | ##### Examples ``` shell script # export a service rio export demo # export a namespace in riofile format rio export -- riofile namespace / default image \u00b6 List images built from the local registry Usage \u00b6 rio image info \u00b6 Show system info Usage \u00b6 rio info inspect \u00b6 Inspect resources Usage \u00b6 rio inspect [TYPE/][NAMESPACE/]SERVICE_NAME Options \u00b6 flag aliases description default --format Edit the raw API object, not the pretty formatted one Examples \u00b6 ```shell script rio inspect svc@v2 inspect a build \u00b6 rio inspect taskrun/affectionate-mirzakhani-mfp5q-ee709-4e40c --- ## install Install the Rio management plane See the [ install docs ]( install . md ) for more info . ##### Usage rio install [OPTIONS] ##### Options | flag | aliases | description | default | |--------------------------|---------|----------------------------------------------------------------------------------------|---------------------------------| | -- check | | Only check status , don ' t deploy controller | | | -- disable - features value | | Manually specify features to disable , supports comma separated values | | | -- enable - debug | | Enable debug logging in controller | | | -- ip - address value | | Manually specify IP addresses to generate rdns domain , supports comma separated values | | | -- yaml | | Only print out k8s yaml manifest | | | -- rdns - url | | Specify Rdns server url to use | https : //api.on-rio.io/v1 | **-- check ** Check if Rio is installed in the current cluster without deploying the Rio controller . If Rio has not been installed , this command might hang on ` Waiting for rio controller to initialize ` . **-- disable - features ** Choose features to be disabled when starting the Rio control plane . Below are a list of available features | Feature | Description | |-------------|---------------------------------------------------| | autoscaling | Auto - scaling services based on in - flight requests | | build | Rio Build , from source code to deployment | | gloo | API gateway backed by gloo | | linkerd | Linkerd service mesh | | letsencrypt | Let ' s Encrypt | | rdns | Acquire DNS from public Rancher DNS service | | dashboard | Rio UI | **-- ip - address ** Manually specify IPAddress for API gateway services . The IP will be used to generate a record for the cluster domain . By default , if this flag is not specified , Rio will use the IP of [ Service Loadbalancer ]( https : //kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/) that points to API gateway. Note : If service loadbalancer cannot be provisioned , [ Nodeport ]( https : //kubernetes.io/docs/concepts/services-networking/service/#nodeport) is used to expose API gateway. ##### Examples ``` shell script # basic install rio install # install with debug and disable some features rio install -- enable - debug -- disable - features linkerd , gloo # print yaml to run manually, with custom ip-address rio install -- yaml -- ip - address 127.0.0.1 kill \u00b6 Kill pods individually or all pods belonging to a service Usage \u00b6 rio kill [SERVICE_NAME/POD_NAME] Examples \u00b6 ```shell script kill a service \u00b6 rio kill demo kill individual pods \u00b6 rio pods # first get pod name rio kill pod/demo-v042dxp-5fb7d8f677-f9xgn --- ## logs Print logs from services or containers ##### Usage rio logs [OPTIONS] SERVICE/BUILD ##### Options | flag | aliases | description | default | | -------------------|----------|---------------------------------------------------------------------------------------------------|---------| | --since value | -s value | Logs since a certain time, either duration (5s, 2m, 3h) or RFC3339 | \"24h\" | | --timestamps | -t | Print the logs with timestamp | | | --tail value | -n value | Number of recent lines to print, -1 for all | 200 | | --container value | -c value | Print the logs of a specific container, use -a for system containers | | | --previous | -p | Print the logs for the previous instance of the container in a pod if it exists, excludes running | | | --init-containers | | Include or exclude init containers | | | --all | -a | Include hidden or systems logs when logging | | | --no-color | --nc | Dont show color when logging | | | --output value | -o value | Output format: [default, raw, json] | default | ##### Examples ``` shell script # get logs from a service rio logs demo # Get logs from a build rio build - history rio logs taskrun / affectionate - mirzakhani - mfp5q - ee709 - 4 e40c # get 1 previous log line for the linkerd - proxy in demo service rio logs --tail 1 --container linkerd-proxy -a demo # ignore init - containers and filter to waiting or terminated pods , include timestamps rio logs --container-state \"terminated,waiting\" --init-containers=false --timestamps demo # target terminated pods of all kinds , format as json rio logs - p - a --output json demo Promote \u00b6 Send 100% of traffic to an app version and scale down other versions. See also weight. Usage \u00b6 rio promote [ OPTIONS ] SERVICE_NAME Options \u00b6 flag aliases description default --duration none How long the rollout should take. An approximation, actual time may fluctuate 0s --pause none Whether to pause all rollouts on current app false Examples \u00b6 ```shell script promote n@v2 \u00b6 rio promote n@v2 promote n@v2 over 1 hour \u00b6 rio promote --duration=1h n@v2 pause last command \u00b6 rio promote --pause=true n@v2 --- ## ps List services ##### Usage rio ps [OPTIONS] ##### Options | flag | aliases | description | default | |-------------|---------|------------------------------------------------------------------------|---------| | -- quiet | - q | Only display Names | | | -- format | | 'json' or 'yaml' or Custom format : '{{.Name}} {{.Obj.Name}}' [ $ FORMAT ] | | | -- all | - a | print all resources , including router and externalservice | | | -- workloads | - w | include apps / v1 Deployments and DaemonSets in output | | ##### Examples ``` shell script # show services and workloads rio ps - w # output json rio ps -- format json # display name and weight in custom format rio ps -- format {{ . Obj . Name }} -> {{ . Data . Weight }} router \u00b6 Route traffic across the mesh Usage \u00b6 rio routers command [ command options ] [ arguments ...] Options \u00b6 flag aliases description default --quiet -q Only display Names --format 'json' or 'yaml' or Custom format: '{{.Name}} {{.Obj.Name}}' [$FORMAT] Examples \u00b6 ```shell script show existing routers \u00b6 rio route #### add / create Create a router . By default appends at the end . Services specified without a version are assumed to be apps . For example ` rio route add x to svc ` would target the svc app endpoint , not the ` svc @v0 ` version . ##### Usage rio router create/add MATCH ACTION [TARGET...] ##### Options | flag | aliases | description | default | |-----------------------------------|---------|------------------------------------------------------|---------| | -- insert | | Insert the rule at the beginning instead of the end | | | -- header value | | Match HTTP header ( format key = value , value optional ) | | | -- fault - percentage value | | Percentage of matching requests to fault | 0 | | -- fault - delay - milli - seconds value | | Inject a delay for fault in milliseconds | 0 | | -- fault - httpcode value | | HTTP code to send for fault injection | 0 | | -- add - header value | | Add HTTP header to request ( format key = value ) | | | -- set - header value | | Override HTTP header to request ( format key = value ) | | | -- remove - header value | | Remove HTTP header to request ( format key = value ) | | | -- retry - attempts value | | How many times to retry | 0 | | -- retry - timeout - seconds value | | Timeout per retry in seconds | 0 | | -- timeout - seconds value | | Timeout in seconds for all requests | 0 | | -- method value | | Match HTTP method , support comma - separated values | | ##### Examples ``` shell script # route to the demo app endpoint rio route add myroute to demo # route a specific path to the demo app ' s version 0 , and insert into first slot rio route add --insert myroute/name.html to demo@v0 See the routers readme for advanced example usage. run \u00b6 Create and run a new service Usage \u00b6 rio run [ OPTIONS ] IMAGE [ COMMAND ] [ ARG... ] Options \u00b6 flag aliases description default --add-host value Add a custom host-to-IP mapping (host=ip) --annotations value Annotations to attach to this service --build-branch value Build repository branch master --build-dockerfile value Set Dockerfile name defaults to Dockerfile --build-context value Set build context . --build-webhook-secret value Set GitHub webhook secret name --build-docker-push-secret value Set docker push secret name --build-clone-secret value Set git clone secret name --build-image-name value Specify custom image name to push --build-registry value Specify to push image to --build-revision value Build git commit or tag --build-pr Enable builds on new pull requests --build-tag Enable builds on any new tags instead of new commits on a branch, requires webhook, does not support polling --build-tag-include Pattern that tags must match --build-tag-exclude Pattern that excludes tags --build-timeout value Timeout for build, ( (ms/s/m/h)) 10m --command value Overwrite the default ENTRYPOINT of the image --config value Configs to expose to the service (format: name[/key]:target) --concurrency value The maximum concurrent request a container can handle (autoscaling) 10 --cpus value Number of CPUs --dns value Set custom DNS servers --dnsoption value Set DNS options (format: key:value or key) --dnssearch value Set custom DNS search domains --env value -e value Set environment variables --env-file value Read in a file of environment variables --global-permission value Permissions to grant to container's service account for all namespaces --group value The GID to run the entrypoint of the container process --health-cmd value Command to run to check health --health-failure-threshold value Consecutive failures needed to report unhealthy 0 --health-header value HTTP Headers to send in GET request for healthcheck --health-initial-delay value Start period for the container to initialize before starting healthchecks ( (ms/s/m/h)) \"0s\" --health-interval value Time between running the check ( (ms/s/m/h)) \"0s\" --health-success-threshold value Consecutive successes needed to report healthy 0 --health-timeout value Maximum time to allow one check to run ( (ms/s/m/h)) \"0s\" --health-url value URL to hit to check health (example: http://:8080/ping) --host-dns Use the host level DNS and not the cluster level DNS --hostname value Container host name --image-pull-policy value Behavior determining when to pull the image (never/always/not-present) \"not-present\" --image-pull-secrets value Specify image pull secrets --interactive -i Keep STDIN open even if not attached --label-file value Read in a line delimited file of labels --label value -l value Set meta data on a container --memory value -m value Memory reservation (format: [ ], where unit = b, k, m or g) --name value -n value Assign a name to the container. Use format [namespace:]name[@version] --net value Set network mode (host) --no-mesh Disable service mesh --permission value Permissions to grant to container's service account in current namespace --ports value -p value Publish a container's port(s) (format: svcport:containerport/protocol) --privileged Run container with privilege --read-only Mount the container's root filesystem as read only --rollout-duration value How long the rollout should take. An approximation, actual time may fluctuate. Affects template services, but not weight or promote commands. \"0s\" --request-timeout-seconds value Set request timeout in seconds 0 --scale value The number of replicas to run or a range for autoscaling (example 1-10) --secret value Secrets to inject to the service (format: name[/key]:target) --stage-only Only stage service when generating new services. Can only be used when template is true --template If true new version is created per git commit. If false update in-place --tty -t Allocate a pseudo-TTY --user value -u value UID[:GID] Sets the UID used and optionally GID for entrypoint process (format: [: ]) --volume value -v value Specify volumes for for services --weight value Specify the weight for the services 0 --workdir value -w value Working directory inside the container Examples \u00b6 ```shell script basic run \u00b6 rio run -p 80 nginx run a named service with set scale, concurrency and ports. Build an image from a github repo \u00b6 rio run -n mysvc --scale 5-10 --concurrency 5 -p 80:8080/http https://github.com/rancher/rio-demo add a version to service \u00b6 rio run --weight 50 -n mysvc@v2 -p 80 nginx set custom readiness probe \u00b6 rio run --health-url http://:8080/status --health-initial-delay 10s --health-interval 5s --health-failure-threshold 5 --health-timeout 5s -p 8080 cbron/mybusybox:dev set permission for containers. By setting permissions, rio will assign a serviceaccount to the pod which will have the corresponding permissions. Global permission means permissions across all namespaces. \u00b6 rio run --global-permission \"create,update,delete services\" --permission \"* apps/deployments\" nginx set host:ip entry in container \u00b6 rio run --add-host db=1.2.3.4 nginx set build parameters \u00b6 rio run --build-branch dev --build-dockerfile Dockerfile.production --build-context . --build-webhook-secret webhook https://github.com/example/exmaple run a service that deploy on any new tag matching '^v' and not match 'alpha' \u00b6 rio run -p 8080 -n tag-demo --build-webhook-secret=githubtoken --build-tag=true --build-tag-include=\"^v\" --build-tag-exclude=\"alpha\" https://github.com/rancher/rio-demo --- ## rm Delete resources ##### Usage rio rm [TYPE/]RESOURCE_NAME ##### Examples ``` shell script # delete service foo rio rm foo # delete multiple resources of different types rio rm svc1 svc2 router / route1 externalservice / foo scale \u00b6 Scale a service to a desired number, or set autoscaling params Usage \u00b6 rio scale [SERVICE=NUMBER_OR_MIN-MAX...] Examples \u00b6 ```shell script rio scale foo=5 autoscaling \u00b6 rio scale foo=1-5 --- ## stage Stage a new revision of a service Note that when using ` --edit` certain values (like `spec.weight`) will be overwritten, and other flags (like `--env`) won't take effect. ##### Usage rio stage [OPTIONS] SERVICE NEW_REVISION ##### Options | flag | aliases | description | default | |------------------|----------|----------------------------------------------------|---------| | -- image value | | Runtime image ( Docker image / OCI image ) | | | -- edit | | Edit the config to change the spec in new revision | | | -- env value | - e value | Set environment variables | | | -- env - file value | | Read in a file of environment variables | | ##### Examples ``` shell script # stage an image (tag v3) to the 2nd version of the demo service rio stage -- image ibuildthecloud / demo : v3 demo v2 # stage the same image with different env variables rio stage - e abc = xyz demo v2 # stage but edit first rio stage -- edit demo v2 system logs \u00b6 Print the logs from the Rio management plane Usage \u00b6 rio system logs system feature \u00b6 View/Edit system feature/configuration Uasge \u00b6 # view system feature rio system feature # edit system feature/configuration rio system feature --edit uninstall \u00b6 Uninstall rio Usage \u00b6 rio uninstall [ OPTIONS ] Options \u00b6 flag aliases description default --namespace value namespace to install system resources \"rio-system\" Examples \u00b6 ```shell script rio uninstall rio uninstall --namespace alt-namespace --- ## up Apply a Riofile ##### Usage rio up [OPTIONS] ##### Options | flag | aliases | description | default | |------------------------------|----------|--------------------------------------------------------------------------------------------------------------|---------| | -- name value | - n | Set stack name , defaults to current directory name | | | -- answers value | | Set answer file | | | -- file value | - f value | Set rio file | | | -- parallel | - p | Run builds in parallel | | | -- branch value | | Set branch when pointing stack to git repo | master | | -- revision value | | Use a specific commit hash | | | -- build - webhook - secret value | | Set GitHub webhook secret name | | | -- build - tag | | Enable builds on any new tags instead of new commits on a branch , requires webhook , does not support polling | | | -- build - tag - include | | Pattern that tags must match | | | -- build - tag - exclude | | Pattern that excludes tags | | | -- build - clone - secret value | | Set name of secret to use with git clone | | | -- push - registry - secret value | | Set secret for pushing to custom registry | | | -- permission value | | Permissions to grant to container ' s service account in current namespace | | ##### Examples `` `shell script # apply a file named ' Riofile ' in current directory rio up # apply stack . yaml as a stack named mystack as 2 nd revision rio up -- name mystack - f stack . yaml - p # apply a riofile from git repo , from a specific branch and commit , using a secret , and setup webhook . rio up -- branch branchname -- build - webhook - secret = githubtoken -- build - clone - secret = mysecret -- revision { commit_sha } https: //github.com/exmaple/example # Set custom permissions to give the stack , and supply answers to riofile questions rio up -- permissions ' * configmaps ' -- answers answerfile . yaml weight \u00b6 Set the percentage of traffic to allocate to a given service version. See also promote. Defaults to an immediate rollout, set duration to perform a gradual rollout Note that once a service version is set to 100% of weight, you must assign weight to other services in order to route traffic to them. For instance if you have svc-a and svc-b, and you set svc-a=100% and then svc-a=50%, svc-b will still have 0% weight and svc-a will still have 100%. You must set svc-b=50% to give it weight. Usage \u00b6 rio weight [ OPTIONS ] SERVICE_NAME = PERCENTAGE Options \u00b6 flag aliases description default --duration How long the rollout should take. An approximation, actual time may fluctuate 0s --pause Whether to pause all rollouts on current app false Examples \u00b6 ```shell script immediately shift 100% of traffic to app n@v0 \u00b6 rio weight n=100 shift n@v2 to 50% of traffic gradually over 5m \u00b6 rio weight --duration=5m n@v2=50 Pause last command at current state, will pause all rollouts on versions in app \u00b6 rio weight --pause=true n@v2=50 ```","title":"CLI Reference"},{"location":"cli-reference/#cli-reference","text":"","title":"CLI Reference"},{"location":"cli-reference/#table-of-contents","text":"attach build build-history cat dashboard edit exec export image info inspect install kill logs promote ps router run rm scale stage system-logs system-features uninstall up weight","title":"Table of Contents"},{"location":"cli-reference/#attach","text":"Attach to a process running in a container","title":"attach"},{"location":"cli-reference/#usage","text":"rio attach [ OPTIONS ] CONTAINER","title":"Usage"},{"location":"cli-reference/#options","text":"flag aliases description default --timeout value Timeout waiting for the container to be created to attach to 1m --pod value Specify pod, default is first pod found","title":"Options"},{"location":"cli-reference/#examples","text":"```shell script rio attach demo rio attach --timeout 30s --pod mydemopod demo --- ## build Build a docker image using buildkitd ##### Usage rio build command [command options] [arguments...] ##### Options | flag | aliases | description | default | |--------------|---------|-------------------------------------------------------------------------|---------| | -- file value | - f | Name of the file to look for build , support both Riofile and Dockerfile | | | -- tag value | - t | Name and optionally a tag in the 'name:tag' format | | | -- build - arg | | Set build - time variables | | | -- no - cache | | Do not use cache when building the image | | | -- help | - h | show help | | ##### Examples ``` shell script # Navigate to directory with Dockerfile and build it into local registry rio build - t test : v1 # See image that was build rio image # Build from riofile insted rio build - t test : v1 -- no - cache - f Riofile . yaml # Now run the image rio run - n test - p 8080 localhost : 5442 / default / test : v1 # Build the image again with new tag rio build - t test : v2 # Now stage the 2nd image rio stage -- image localhost : 5442 / default / test : v2 test v2","title":"Examples"},{"location":"cli-reference/#build-history","text":"Show previous builds","title":"build-history"},{"location":"cli-reference/#usage_1","text":"rio build - history [ command options ] [ arguments ...]","title":"Usage"},{"location":"cli-reference/#options_1","text":"flag aliases description default --quiet -q Only display Names --format value 'json' or 'yaml' or Custom format: '{{.Obj.Name}}' [$FORMAT]","title":"Options"},{"location":"cli-reference/#examples_1","text":"```shell script","title":"Examples"},{"location":"cli-reference/#see-previous-builds-from-stacks-or-workloads","text":"rio build-history","title":"see previous builds from stacks or workloads"},{"location":"cli-reference/#custom-output-format","text":"rio build-history --format {{.Obj.Name}} --- ## cat Print the contents of a config ##### Usage rio cat [OPTIONS] [NAME...] ##### Options | flag | aliases | description | default | | -------|---------|-------------------------|---------| | --key | -k | The values which to cat | | ##### Examples ``` shell script # cat a configmap rio cat configmap / config - foo # cat a key from a configmap rio cat --key=a configmap/config-foo","title":"custom output format"},{"location":"cli-reference/#dashboard","text":"Open the dashboard in a browser","title":"dashboard"},{"location":"cli-reference/#usage_2","text":"rio dashboard [ OPTIONS ]","title":"Usage"},{"location":"cli-reference/#options_2","text":"flag aliases description default --reset-admin Reset admin password","title":"Options"},{"location":"cli-reference/#examples_2","text":"```shell script","title":"Examples"},{"location":"cli-reference/#reset-admin-pw","text":"rio dashboard --reset-admin --- ## edit Edit resources ##### Usage rio edit [TYPE/]RESOURCE_NAME ##### Options | flag | aliases | description | default | |-------|---------|-------------------------------------------------------|---------| | -- raw | | Edit the raw API object , not the pretty formatted one | | ##### Examples ``` shell script rio edit demo @v4 rio edit router / myrouter","title":"reset admin pw"},{"location":"cli-reference/#exec","text":"Run a command in a running container","title":"exec"},{"location":"cli-reference/#usage_3","text":"rio exec [ OPTIONS ] CONTAINER COMMAND [ ARG... ]","title":"Usage"},{"location":"cli-reference/#options_3","text":"flag aliases description default --stdin -i Pass stdin to the container --tty -t Stdin is a TTY --container value -c value Specify container in pod, default is first container --pod value Specify pod, default is first pod found","title":"Options"},{"location":"cli-reference/#examples_3","text":"```shell script","title":"Examples"},{"location":"cli-reference/#ssh-into-running-container","text":"rio exec -it demo sh","title":"ssh into running container"},{"location":"cli-reference/#this-is-equivalent-of-doing","text":"rio exec --tty --stdin demo sh","title":"this is equivalent of doing"},{"location":"cli-reference/#choose-pod-and-container","text":"rio exec -it --pod mypod --container server demo sh --- ## export Export a namespace or service ##### Usage rio export [TYPE/]NAMESPACE_OR_SERVICE ##### Options | flag | aliases | description | default | |----------------|---------|----------------------------------------------------|---------| | -- format value | | Specify output format , yaml / json . Defaults to yaml | yaml | | -- riofile | | Export riofile format | | ##### Examples ``` shell script # export a service rio export demo # export a namespace in riofile format rio export -- riofile namespace / default","title":"choose pod and container"},{"location":"cli-reference/#image","text":"List images built from the local registry","title":"image"},{"location":"cli-reference/#usage_4","text":"rio image","title":"Usage"},{"location":"cli-reference/#info","text":"Show system info","title":"info"},{"location":"cli-reference/#usage_5","text":"rio info","title":"Usage"},{"location":"cli-reference/#inspect","text":"Inspect resources","title":"inspect"},{"location":"cli-reference/#usage_6","text":"rio inspect [TYPE/][NAMESPACE/]SERVICE_NAME","title":"Usage"},{"location":"cli-reference/#options_4","text":"flag aliases description default --format Edit the raw API object, not the pretty formatted one","title":"Options"},{"location":"cli-reference/#examples_4","text":"```shell script rio inspect svc@v2","title":"Examples"},{"location":"cli-reference/#inspect-a-build","text":"rio inspect taskrun/affectionate-mirzakhani-mfp5q-ee709-4e40c --- ## install Install the Rio management plane See the [ install docs ]( install . md ) for more info . ##### Usage rio install [OPTIONS] ##### Options | flag | aliases | description | default | |--------------------------|---------|----------------------------------------------------------------------------------------|---------------------------------| | -- check | | Only check status , don ' t deploy controller | | | -- disable - features value | | Manually specify features to disable , supports comma separated values | | | -- enable - debug | | Enable debug logging in controller | | | -- ip - address value | | Manually specify IP addresses to generate rdns domain , supports comma separated values | | | -- yaml | | Only print out k8s yaml manifest | | | -- rdns - url | | Specify Rdns server url to use | https : //api.on-rio.io/v1 | **-- check ** Check if Rio is installed in the current cluster without deploying the Rio controller . If Rio has not been installed , this command might hang on ` Waiting for rio controller to initialize ` . **-- disable - features ** Choose features to be disabled when starting the Rio control plane . Below are a list of available features | Feature | Description | |-------------|---------------------------------------------------| | autoscaling | Auto - scaling services based on in - flight requests | | build | Rio Build , from source code to deployment | | gloo | API gateway backed by gloo | | linkerd | Linkerd service mesh | | letsencrypt | Let ' s Encrypt | | rdns | Acquire DNS from public Rancher DNS service | | dashboard | Rio UI | **-- ip - address ** Manually specify IPAddress for API gateway services . The IP will be used to generate a record for the cluster domain . By default , if this flag is not specified , Rio will use the IP of [ Service Loadbalancer ]( https : //kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/) that points to API gateway. Note : If service loadbalancer cannot be provisioned , [ Nodeport ]( https : //kubernetes.io/docs/concepts/services-networking/service/#nodeport) is used to expose API gateway. ##### Examples ``` shell script # basic install rio install # install with debug and disable some features rio install -- enable - debug -- disable - features linkerd , gloo # print yaml to run manually, with custom ip-address rio install -- yaml -- ip - address 127.0.0.1","title":"inspect a build"},{"location":"cli-reference/#kill","text":"Kill pods individually or all pods belonging to a service","title":"kill"},{"location":"cli-reference/#usage_7","text":"rio kill [SERVICE_NAME/POD_NAME]","title":"Usage"},{"location":"cli-reference/#examples_5","text":"```shell script","title":"Examples"},{"location":"cli-reference/#kill-a-service","text":"rio kill demo","title":"kill a service"},{"location":"cli-reference/#kill-individual-pods","text":"rio pods # first get pod name rio kill pod/demo-v042dxp-5fb7d8f677-f9xgn --- ## logs Print logs from services or containers ##### Usage rio logs [OPTIONS] SERVICE/BUILD ##### Options | flag | aliases | description | default | | -------------------|----------|---------------------------------------------------------------------------------------------------|---------| | --since value | -s value | Logs since a certain time, either duration (5s, 2m, 3h) or RFC3339 | \"24h\" | | --timestamps | -t | Print the logs with timestamp | | | --tail value | -n value | Number of recent lines to print, -1 for all | 200 | | --container value | -c value | Print the logs of a specific container, use -a for system containers | | | --previous | -p | Print the logs for the previous instance of the container in a pod if it exists, excludes running | | | --init-containers | | Include or exclude init containers | | | --all | -a | Include hidden or systems logs when logging | | | --no-color | --nc | Dont show color when logging | | | --output value | -o value | Output format: [default, raw, json] | default | ##### Examples ``` shell script # get logs from a service rio logs demo # Get logs from a build rio build - history rio logs taskrun / affectionate - mirzakhani - mfp5q - ee709 - 4 e40c # get 1 previous log line for the linkerd - proxy in demo service rio logs --tail 1 --container linkerd-proxy -a demo # ignore init - containers and filter to waiting or terminated pods , include timestamps rio logs --container-state \"terminated,waiting\" --init-containers=false --timestamps demo # target terminated pods of all kinds , format as json rio logs - p - a --output json demo","title":"kill individual pods"},{"location":"cli-reference/#promote","text":"Send 100% of traffic to an app version and scale down other versions. See also weight.","title":"Promote"},{"location":"cli-reference/#usage_8","text":"rio promote [ OPTIONS ] SERVICE_NAME","title":"Usage"},{"location":"cli-reference/#options_5","text":"flag aliases description default --duration none How long the rollout should take. An approximation, actual time may fluctuate 0s --pause none Whether to pause all rollouts on current app false","title":"Options"},{"location":"cli-reference/#examples_6","text":"```shell script","title":"Examples"},{"location":"cli-reference/#promote-nv2","text":"rio promote n@v2","title":"promote n@v2"},{"location":"cli-reference/#promote-nv2-over-1-hour","text":"rio promote --duration=1h n@v2","title":"promote n@v2 over 1 hour"},{"location":"cli-reference/#pause-last-command","text":"rio promote --pause=true n@v2 --- ## ps List services ##### Usage rio ps [OPTIONS] ##### Options | flag | aliases | description | default | |-------------|---------|------------------------------------------------------------------------|---------| | -- quiet | - q | Only display Names | | | -- format | | 'json' or 'yaml' or Custom format : '{{.Name}} {{.Obj.Name}}' [ $ FORMAT ] | | | -- all | - a | print all resources , including router and externalservice | | | -- workloads | - w | include apps / v1 Deployments and DaemonSets in output | | ##### Examples ``` shell script # show services and workloads rio ps - w # output json rio ps -- format json # display name and weight in custom format rio ps -- format {{ . Obj . Name }} -> {{ . Data . Weight }}","title":"pause last command"},{"location":"cli-reference/#router","text":"Route traffic across the mesh","title":"router"},{"location":"cli-reference/#usage_9","text":"rio routers command [ command options ] [ arguments ...]","title":"Usage"},{"location":"cli-reference/#options_6","text":"flag aliases description default --quiet -q Only display Names --format 'json' or 'yaml' or Custom format: '{{.Name}} {{.Obj.Name}}' [$FORMAT]","title":"Options"},{"location":"cli-reference/#examples_7","text":"```shell script","title":"Examples"},{"location":"cli-reference/#show-existing-routers","text":"rio route #### add / create Create a router . By default appends at the end . Services specified without a version are assumed to be apps . For example ` rio route add x to svc ` would target the svc app endpoint , not the ` svc @v0 ` version . ##### Usage rio router create/add MATCH ACTION [TARGET...] ##### Options | flag | aliases | description | default | |-----------------------------------|---------|------------------------------------------------------|---------| | -- insert | | Insert the rule at the beginning instead of the end | | | -- header value | | Match HTTP header ( format key = value , value optional ) | | | -- fault - percentage value | | Percentage of matching requests to fault | 0 | | -- fault - delay - milli - seconds value | | Inject a delay for fault in milliseconds | 0 | | -- fault - httpcode value | | HTTP code to send for fault injection | 0 | | -- add - header value | | Add HTTP header to request ( format key = value ) | | | -- set - header value | | Override HTTP header to request ( format key = value ) | | | -- remove - header value | | Remove HTTP header to request ( format key = value ) | | | -- retry - attempts value | | How many times to retry | 0 | | -- retry - timeout - seconds value | | Timeout per retry in seconds | 0 | | -- timeout - seconds value | | Timeout in seconds for all requests | 0 | | -- method value | | Match HTTP method , support comma - separated values | | ##### Examples ``` shell script # route to the demo app endpoint rio route add myroute to demo # route a specific path to the demo app ' s version 0 , and insert into first slot rio route add --insert myroute/name.html to demo@v0 See the routers readme for advanced example usage.","title":"show existing routers"},{"location":"cli-reference/#run","text":"Create and run a new service","title":"run"},{"location":"cli-reference/#usage_10","text":"rio run [ OPTIONS ] IMAGE [ COMMAND ] [ ARG... ]","title":"Usage"},{"location":"cli-reference/#options_7","text":"flag aliases description default --add-host value Add a custom host-to-IP mapping (host=ip) --annotations value Annotations to attach to this service --build-branch value Build repository branch master --build-dockerfile value Set Dockerfile name defaults to Dockerfile --build-context value Set build context . --build-webhook-secret value Set GitHub webhook secret name --build-docker-push-secret value Set docker push secret name --build-clone-secret value Set git clone secret name --build-image-name value Specify custom image name to push --build-registry value Specify to push image to --build-revision value Build git commit or tag --build-pr Enable builds on new pull requests --build-tag Enable builds on any new tags instead of new commits on a branch, requires webhook, does not support polling --build-tag-include Pattern that tags must match --build-tag-exclude Pattern that excludes tags --build-timeout value Timeout for build, ( (ms/s/m/h)) 10m --command value Overwrite the default ENTRYPOINT of the image --config value Configs to expose to the service (format: name[/key]:target) --concurrency value The maximum concurrent request a container can handle (autoscaling) 10 --cpus value Number of CPUs --dns value Set custom DNS servers --dnsoption value Set DNS options (format: key:value or key) --dnssearch value Set custom DNS search domains --env value -e value Set environment variables --env-file value Read in a file of environment variables --global-permission value Permissions to grant to container's service account for all namespaces --group value The GID to run the entrypoint of the container process --health-cmd value Command to run to check health --health-failure-threshold value Consecutive failures needed to report unhealthy 0 --health-header value HTTP Headers to send in GET request for healthcheck --health-initial-delay value Start period for the container to initialize before starting healthchecks ( (ms/s/m/h)) \"0s\" --health-interval value Time between running the check ( (ms/s/m/h)) \"0s\" --health-success-threshold value Consecutive successes needed to report healthy 0 --health-timeout value Maximum time to allow one check to run ( (ms/s/m/h)) \"0s\" --health-url value URL to hit to check health (example: http://:8080/ping) --host-dns Use the host level DNS and not the cluster level DNS --hostname value Container host name --image-pull-policy value Behavior determining when to pull the image (never/always/not-present) \"not-present\" --image-pull-secrets value Specify image pull secrets --interactive -i Keep STDIN open even if not attached --label-file value Read in a line delimited file of labels --label value -l value Set meta data on a container --memory value -m value Memory reservation (format: [ ], where unit = b, k, m or g) --name value -n value Assign a name to the container. Use format [namespace:]name[@version] --net value Set network mode (host) --no-mesh Disable service mesh --permission value Permissions to grant to container's service account in current namespace --ports value -p value Publish a container's port(s) (format: svcport:containerport/protocol) --privileged Run container with privilege --read-only Mount the container's root filesystem as read only --rollout-duration value How long the rollout should take. An approximation, actual time may fluctuate. Affects template services, but not weight or promote commands. \"0s\" --request-timeout-seconds value Set request timeout in seconds 0 --scale value The number of replicas to run or a range for autoscaling (example 1-10) --secret value Secrets to inject to the service (format: name[/key]:target) --stage-only Only stage service when generating new services. Can only be used when template is true --template If true new version is created per git commit. If false update in-place --tty -t Allocate a pseudo-TTY --user value -u value UID[:GID] Sets the UID used and optionally GID for entrypoint process (format: [: ]) --volume value -v value Specify volumes for for services --weight value Specify the weight for the services 0 --workdir value -w value Working directory inside the container","title":"Options"},{"location":"cli-reference/#examples_8","text":"```shell script","title":"Examples"},{"location":"cli-reference/#basic-run","text":"rio run -p 80 nginx","title":"basic run"},{"location":"cli-reference/#run-a-named-service-with-set-scale-concurrency-and-ports-build-an-image-from-a-github-repo","text":"rio run -n mysvc --scale 5-10 --concurrency 5 -p 80:8080/http https://github.com/rancher/rio-demo","title":"run a named service with set scale, concurrency and ports. Build an image from a github repo"},{"location":"cli-reference/#add-a-version-to-service","text":"rio run --weight 50 -n mysvc@v2 -p 80 nginx","title":"add a version to service"},{"location":"cli-reference/#set-custom-readiness-probe","text":"rio run --health-url http://:8080/status --health-initial-delay 10s --health-interval 5s --health-failure-threshold 5 --health-timeout 5s -p 8080 cbron/mybusybox:dev","title":"set custom readiness probe"},{"location":"cli-reference/#set-permission-for-containers-by-setting-permissions-rio-will-assign-a-serviceaccount-to-the-pod-which-will-have-the-corresponding-permissions-global-permission-means-permissions-across-all-namespaces","text":"rio run --global-permission \"create,update,delete services\" --permission \"* apps/deployments\" nginx","title":"set permission for containers. By setting permissions, rio will assign a serviceaccount to the pod which will have the corresponding permissions. Global permission means permissions across all namespaces."},{"location":"cli-reference/#set-hostip-entry-in-container","text":"rio run --add-host db=1.2.3.4 nginx","title":"set host:ip entry in container"},{"location":"cli-reference/#set-build-parameters","text":"rio run --build-branch dev --build-dockerfile Dockerfile.production --build-context . --build-webhook-secret webhook https://github.com/example/exmaple","title":"set build parameters"},{"location":"cli-reference/#run-a-service-that-deploy-on-any-new-tag-matching-v-and-not-match-alpha","text":"rio run -p 8080 -n tag-demo --build-webhook-secret=githubtoken --build-tag=true --build-tag-include=\"^v\" --build-tag-exclude=\"alpha\" https://github.com/rancher/rio-demo --- ## rm Delete resources ##### Usage rio rm [TYPE/]RESOURCE_NAME ##### Examples ``` shell script # delete service foo rio rm foo # delete multiple resources of different types rio rm svc1 svc2 router / route1 externalservice / foo","title":"run a service that deploy on any new tag matching '^v' and not match 'alpha'"},{"location":"cli-reference/#scale","text":"Scale a service to a desired number, or set autoscaling params","title":"scale"},{"location":"cli-reference/#usage_11","text":"rio scale [SERVICE=NUMBER_OR_MIN-MAX...]","title":"Usage"},{"location":"cli-reference/#examples_9","text":"```shell script rio scale foo=5","title":"Examples"},{"location":"cli-reference/#autoscaling","text":"rio scale foo=1-5 --- ## stage Stage a new revision of a service Note that when using ` --edit` certain values (like `spec.weight`) will be overwritten, and other flags (like `--env`) won't take effect. ##### Usage rio stage [OPTIONS] SERVICE NEW_REVISION ##### Options | flag | aliases | description | default | |------------------|----------|----------------------------------------------------|---------| | -- image value | | Runtime image ( Docker image / OCI image ) | | | -- edit | | Edit the config to change the spec in new revision | | | -- env value | - e value | Set environment variables | | | -- env - file value | | Read in a file of environment variables | | ##### Examples ``` shell script # stage an image (tag v3) to the 2nd version of the demo service rio stage -- image ibuildthecloud / demo : v3 demo v2 # stage the same image with different env variables rio stage - e abc = xyz demo v2 # stage but edit first rio stage -- edit demo v2","title":"autoscaling"},{"location":"cli-reference/#system-logs","text":"Print the logs from the Rio management plane","title":"system logs"},{"location":"cli-reference/#usage_12","text":"rio system logs","title":"Usage"},{"location":"cli-reference/#system-feature","text":"View/Edit system feature/configuration","title":"system feature"},{"location":"cli-reference/#uasge","text":"# view system feature rio system feature # edit system feature/configuration rio system feature --edit","title":"Uasge"},{"location":"cli-reference/#uninstall","text":"Uninstall rio","title":"uninstall"},{"location":"cli-reference/#usage_13","text":"rio uninstall [ OPTIONS ]","title":"Usage"},{"location":"cli-reference/#options_8","text":"flag aliases description default --namespace value namespace to install system resources \"rio-system\"","title":"Options"},{"location":"cli-reference/#examples_10","text":"```shell script rio uninstall rio uninstall --namespace alt-namespace --- ## up Apply a Riofile ##### Usage rio up [OPTIONS] ##### Options | flag | aliases | description | default | |------------------------------|----------|--------------------------------------------------------------------------------------------------------------|---------| | -- name value | - n | Set stack name , defaults to current directory name | | | -- answers value | | Set answer file | | | -- file value | - f value | Set rio file | | | -- parallel | - p | Run builds in parallel | | | -- branch value | | Set branch when pointing stack to git repo | master | | -- revision value | | Use a specific commit hash | | | -- build - webhook - secret value | | Set GitHub webhook secret name | | | -- build - tag | | Enable builds on any new tags instead of new commits on a branch , requires webhook , does not support polling | | | -- build - tag - include | | Pattern that tags must match | | | -- build - tag - exclude | | Pattern that excludes tags | | | -- build - clone - secret value | | Set name of secret to use with git clone | | | -- push - registry - secret value | | Set secret for pushing to custom registry | | | -- permission value | | Permissions to grant to container ' s service account in current namespace | | ##### Examples `` `shell script # apply a file named ' Riofile ' in current directory rio up # apply stack . yaml as a stack named mystack as 2 nd revision rio up -- name mystack - f stack . yaml - p # apply a riofile from git repo , from a specific branch and commit , using a secret , and setup webhook . rio up -- branch branchname -- build - webhook - secret = githubtoken -- build - clone - secret = mysecret -- revision { commit_sha } https: //github.com/exmaple/example # Set custom permissions to give the stack , and supply answers to riofile questions rio up -- permissions ' * configmaps ' -- answers answerfile . yaml","title":"Examples"},{"location":"cli-reference/#weight","text":"Set the percentage of traffic to allocate to a given service version. See also promote. Defaults to an immediate rollout, set duration to perform a gradual rollout Note that once a service version is set to 100% of weight, you must assign weight to other services in order to route traffic to them. For instance if you have svc-a and svc-b, and you set svc-a=100% and then svc-a=50%, svc-b will still have 0% weight and svc-a will still have 100%. You must set svc-b=50% to give it weight.","title":"weight"},{"location":"cli-reference/#usage_14","text":"rio weight [ OPTIONS ] SERVICE_NAME = PERCENTAGE","title":"Usage"},{"location":"cli-reference/#options_9","text":"flag aliases description default --duration How long the rollout should take. An approximation, actual time may fluctuate 0s --pause Whether to pause all rollouts on current app false","title":"Options"},{"location":"cli-reference/#examples_11","text":"```shell script","title":"Examples"},{"location":"cli-reference/#immediately-shift-100-of-traffic-to-app-nv0","text":"rio weight n=100","title":"immediately shift 100% of traffic to app n@v0"},{"location":"cli-reference/#shift-nv2-to-50-of-traffic-gradually-over-5m","text":"rio weight --duration=5m n@v2=50","title":"shift n@v2 to 50% of traffic gradually over 5m"},{"location":"cli-reference/#pause-last-command-at-current-state-will-pause-all-rollouts-on-versions-in-app","text":"rio weight --pause=true n@v2=50 ```","title":"Pause last command at current state, will pause all rollouts on versions in app"},{"location":"concepts/","text":"Concepts \u00b6 Rio introduces a small number of new concepts: Service, Router, External Service, and Domain. In addition, it reuses two existing Kubernetes resources: ConfigMaps and Secrets. The power of Rio resides in its ability to utilize the power of Kubernetes, Linkerd service mesh, and Tekton CI/CD through a simple set of concepts. Service \u00b6 Service is the core concept in Rio. Services are a scalable set of identical containers. Running containers in Rio ( rio run ) creates a Service. That can be manually scaled with rio scale . Services are assigned a DNS name so that they can be discovered and accessed by other services. Stack \u00b6 Stack is an abstraction of Riofile . Riofile is a file that is similar to docker-compose. In it, multiple Rio resources (services, routers, etc.) can be defined in a single file with simplified syntax that is easy to memorize. Router \u00b6 Router is a resource that manages load balancing and traffic routing rules. Routing rules can route based on hostname, path, HTTP headers, protocol, and source. External Service \u00b6 External Service provides a way to register external IPs or hostnames in the service mesh so they can be accessed by Rio services. Also, Rio services running in one namespace can be declared as ExternalServices in another namespace. Public Domain \u00b6 Public Domain can be configured to assign a service or router a vanity domain like www.myproductionsite.com. Cluster Domain \u00b6 Cluster Domain is a DNS name that can be configured globally on each service so that each service will have an endpoint like $service_name-$namespace.xxx.clusterdomain. By default Rio will create and assign the on-rio.io DNS name to each service, so it will have a DNS name like $name-$namespace.xxx.on-rio.io . Configs \u00b6 ConfigMaps are a standard Kubernetes resource and can be referenced by Rio services. They are pieces of configuration that can be mounted into pods so that configuration data can be separated from image artifacts. Secrets \u00b6 Secrets are a standard Kubernetes resource and can be referenced by Rio services. They contain sensitive data that can be mounted into pods.","title":"Rio concept"},{"location":"concepts/#concepts","text":"Rio introduces a small number of new concepts: Service, Router, External Service, and Domain. In addition, it reuses two existing Kubernetes resources: ConfigMaps and Secrets. The power of Rio resides in its ability to utilize the power of Kubernetes, Linkerd service mesh, and Tekton CI/CD through a simple set of concepts.","title":"Concepts"},{"location":"concepts/#service","text":"Service is the core concept in Rio. Services are a scalable set of identical containers. Running containers in Rio ( rio run ) creates a Service. That can be manually scaled with rio scale . Services are assigned a DNS name so that they can be discovered and accessed by other services.","title":"Service"},{"location":"concepts/#stack","text":"Stack is an abstraction of Riofile . Riofile is a file that is similar to docker-compose. In it, multiple Rio resources (services, routers, etc.) can be defined in a single file with simplified syntax that is easy to memorize.","title":"Stack"},{"location":"concepts/#router","text":"Router is a resource that manages load balancing and traffic routing rules. Routing rules can route based on hostname, path, HTTP headers, protocol, and source.","title":"Router"},{"location":"concepts/#external-service","text":"External Service provides a way to register external IPs or hostnames in the service mesh so they can be accessed by Rio services. Also, Rio services running in one namespace can be declared as ExternalServices in another namespace.","title":"External Service"},{"location":"concepts/#public-domain","text":"Public Domain can be configured to assign a service or router a vanity domain like www.myproductionsite.com.","title":"Public Domain"},{"location":"concepts/#cluster-domain","text":"Cluster Domain is a DNS name that can be configured globally on each service so that each service will have an endpoint like $service_name-$namespace.xxx.clusterdomain. By default Rio will create and assign the on-rio.io DNS name to each service, so it will have a DNS name like $name-$namespace.xxx.on-rio.io .","title":"Cluster Domain"},{"location":"concepts/#configs","text":"ConfigMaps are a standard Kubernetes resource and can be referenced by Rio services. They are pieces of configuration that can be mounted into pods so that configuration data can be separated from image artifacts.","title":"Configs"},{"location":"concepts/#secrets","text":"Secrets are a standard Kubernetes resource and can be referenced by Rio services. They contain sensitive data that can be mounted into pods.","title":"Secrets"},{"location":"continuous-deployment/","text":"Continuous Deployment \u00b6 Rio enables continuous deployment with GitHub by default. This allows developers to streamline their focus on their git repository and worry less about their deploys. The most versatile use case is in this example . Basic Example \u00b6 Deploy a workload with Rio from a public GitHub repository that you have push access to: rio run -n cd-demo -p 8080 https://github.com/rancher/rio-demo Make a commit to the master branch of the repo. You should notice that within 15 seconds, Rio rebuilds your workload ( rio build-history ) and updates it to match the committed changes. Advanced Usage \u00b6 Pull Request Builds \u00b6 This feature uses a webhook to create a deployment when submitting a Pull Request to your tracked branch (master by default). A new workload version will be staged in Rio, associated to the same app that was initially created. You can view the endpoint results directly from the PR by clicking \"View deployment\" in GitHub. If the pull request is merged, it will then update the app endpoint in Rio to point to this new version. It only takes 2 steps: Configure Webhook for your repository. For this example, you only need to set the webhook up. Run rio run -p 8080 -n example-cd --build-webhook-secret = githubtoken --build-pr --template https://github.com/example/example-repo NOTE: if your repository is private, you will also need to create a credentials secret and use the correct additional flags when running your workload. Automatic Versioning \u00b6 Notice the --template flag specified in the Pull Request Builds scenario. With this flag set, Rio will automatically configure versions for this workload when new commits are pushed to the GitHub repo. As soon as the workload is ready, it will promote that version to have 100% of the app endpoint weight. The only case where it won't automatically promote is when using the --build-pr flag as well and the build is from the PR branch. If the --template flag is not set, then every subsequent build will overwrite the current version, including builds from the PR branch with --build-pr flag set. Private Github Repo \u00b6 You can do this with Git Basic Auth or SSH Auth: - Git Basic Auth: 1. Configure git basic auth credential secrets: ``` bash $ rio secret create -- git - basic - auth Select namespace [ default ] : $ ( put the same namespace with your workload ) git url []: $ ( for example : https : // github . com ) username []: $ ( your GH username ) password [ ****** ] : $ ( your GH password ) ``` 2. Rio will automatically use this secret now when doing standard git checkout , so no additional flags need to be passed . For example : ``` bash rio run - p 8080 https : // github . com / example / example - private - repo ``` SSH Auth: Configure git sshkey auth credential secrets. This should use a key that does not have a password associated to it: bash $ rio secret create --git-sshkey-auth Select namespace[default]: $(put the same namespace with your workload) git url[]: $(put your github url. Leave out http/https. Example: github.com) ssh_key_path[]: $(type the path to your ssh private key) Tell rio to do ssh checkout from git. For example: bash rio run --build-clone-secret gitcredential-ssh -p 8080 git@github.com:example/example.git Private Docker Registry \u00b6 Configure the Docker credential secret. $ rio secret create --docker Select namespace [ default ] : $( put the same namespace with your workload ) Registry URL [ https://index.docker.io/v1/ ] : $( found with \"docker info | grep Registry\" ) username [] : $( your docker username ) password [ ****** ] : $( your docker password ) Push your image to docker registry: rio run --image-pull-secrets dockerconfig --build-docker-push-secret dockerconfig -p 8080 --build-registry index.docker.io --build-image-name $username /repo https://github.com/example/example.git Useful Options \u00b6 There are many options available for use when running workloads in Rio. These are just a few that are useful for CD: Option Type Description --build-branch string Build repository branch (default: \"master\") --build-dockerfile string Set Dockerfile name, defaults to Dockerfile --build-context string Set build context, defaults to . --build-webhook-secret string Set GitHub webhook secret name --build-clone-secret string Set git clone secret name --build-image-name string Specify custom image name to push --build-pr boolean Enable pull request builds --build-timeout string Timeout for build, default to 10m (ms --image-pull-secrets string Specify image pull secrets --template boolean If true new version is created per git commit. If false update in-place","title":"Continuous Delivery with Rio"},{"location":"continuous-deployment/#continuous-deployment","text":"Rio enables continuous deployment with GitHub by default. This allows developers to streamline their focus on their git repository and worry less about their deploys. The most versatile use case is in this example .","title":"Continuous Deployment"},{"location":"continuous-deployment/#basic-example","text":"Deploy a workload with Rio from a public GitHub repository that you have push access to: rio run -n cd-demo -p 8080 https://github.com/rancher/rio-demo Make a commit to the master branch of the repo. You should notice that within 15 seconds, Rio rebuilds your workload ( rio build-history ) and updates it to match the committed changes.","title":"Basic Example"},{"location":"continuous-deployment/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"continuous-deployment/#pull-request-builds","text":"This feature uses a webhook to create a deployment when submitting a Pull Request to your tracked branch (master by default). A new workload version will be staged in Rio, associated to the same app that was initially created. You can view the endpoint results directly from the PR by clicking \"View deployment\" in GitHub. If the pull request is merged, it will then update the app endpoint in Rio to point to this new version. It only takes 2 steps: Configure Webhook for your repository. For this example, you only need to set the webhook up. Run rio run -p 8080 -n example-cd --build-webhook-secret = githubtoken --build-pr --template https://github.com/example/example-repo NOTE: if your repository is private, you will also need to create a credentials secret and use the correct additional flags when running your workload.","title":"Pull Request Builds"},{"location":"continuous-deployment/#automatic-versioning","text":"Notice the --template flag specified in the Pull Request Builds scenario. With this flag set, Rio will automatically configure versions for this workload when new commits are pushed to the GitHub repo. As soon as the workload is ready, it will promote that version to have 100% of the app endpoint weight. The only case where it won't automatically promote is when using the --build-pr flag as well and the build is from the PR branch. If the --template flag is not set, then every subsequent build will overwrite the current version, including builds from the PR branch with --build-pr flag set.","title":"Automatic Versioning"},{"location":"continuous-deployment/#private-github-repo","text":"You can do this with Git Basic Auth or SSH Auth: - Git Basic Auth: 1. Configure git basic auth credential secrets: ``` bash $ rio secret create -- git - basic - auth Select namespace [ default ] : $ ( put the same namespace with your workload ) git url []: $ ( for example : https : // github . com ) username []: $ ( your GH username ) password [ ****** ] : $ ( your GH password ) ``` 2. Rio will automatically use this secret now when doing standard git checkout , so no additional flags need to be passed . For example : ``` bash rio run - p 8080 https : // github . com / example / example - private - repo ``` SSH Auth: Configure git sshkey auth credential secrets. This should use a key that does not have a password associated to it: bash $ rio secret create --git-sshkey-auth Select namespace[default]: $(put the same namespace with your workload) git url[]: $(put your github url. Leave out http/https. Example: github.com) ssh_key_path[]: $(type the path to your ssh private key) Tell rio to do ssh checkout from git. For example: bash rio run --build-clone-secret gitcredential-ssh -p 8080 git@github.com:example/example.git","title":"Private Github Repo"},{"location":"continuous-deployment/#private-docker-registry","text":"Configure the Docker credential secret. $ rio secret create --docker Select namespace [ default ] : $( put the same namespace with your workload ) Registry URL [ https://index.docker.io/v1/ ] : $( found with \"docker info | grep Registry\" ) username [] : $( your docker username ) password [ ****** ] : $( your docker password ) Push your image to docker registry: rio run --image-pull-secrets dockerconfig --build-docker-push-secret dockerconfig -p 8080 --build-registry index.docker.io --build-image-name $username /repo https://github.com/example/example.git","title":"Private Docker Registry"},{"location":"continuous-deployment/#useful-options","text":"There are many options available for use when running workloads in Rio. These are just a few that are useful for CD: Option Type Description --build-branch string Build repository branch (default: \"master\") --build-dockerfile string Set Dockerfile name, defaults to Dockerfile --build-context string Set build context, defaults to . --build-webhook-secret string Set GitHub webhook secret name --build-clone-secret string Set git clone secret name --build-image-name string Specify custom image name to push --build-pr boolean Enable pull request builds --build-timeout string Timeout for build, default to 10m (ms --image-pull-secrets string Specify image pull secrets --template boolean If true new version is created per git commit. If false update in-place","title":"Useful Options"},{"location":"dashboard/","text":"Dashboard \u00b6 Rio ships with a built-in dashboard. To enable the dashboard: $ rio dashboard Then follow the instructions prompted in UI. If a browser does not automatically open, the output of the command should have a URL that you can use to access the dashboard.","title":"Using Dashboard"},{"location":"dashboard/#dashboard","text":"Rio ships with a built-in dashboard. To enable the dashboard: $ rio dashboard Then follow the instructions prompted in UI. If a browser does not automatically open, the output of the command should have a URL that you can use to access the dashboard.","title":"Dashboard"},{"location":"developing-application-using-rio/","text":"Developing application using Rio \u00b6 The Rio CLI provides an easy way to build and deploy your applications into a Kubernetes cluster. It takes advantage of Riofile and buildkit to build images and update deployments with them. Using Riofile to develop applications \u00b6 Let's use this repo as an example: Clone this repo. $ git clone https://github.com/ibuildthecloud/rancher-demo Go into the repo $ cd rancher-demo Create a Riofile in the root directory services : demo : image : ./ # By giving image a relative path, it tells rio to use this as build context port : 8080/http # defining ports to expose Run $ rio up Check with rio ps . It should create a service with URL serving the content. It should be serving blue cows. Open the Dockerfile and change ENV COW_COLOR from blue to red . Re-run rio up . Once it is finished, it should already be updated with new images and start serving red cows. By following the example above, you can now develop your code locally and run rio up to see your code changes automatically. Note : This feature requires a Dockerfile. Manually build and run \u00b6 You can also use the Rio CLI to build and run an image locally in your cluster. Go to the root directory of repo and run $ rio build Wait for the image to be built. Once it is done, run $ rio images Run containers with images you just built $ rio run -p 8080 localhost:5442/default/rancher-demo:latest","title":"Using Rio for Developing Your Application"},{"location":"developing-application-using-rio/#developing-application-using-rio","text":"The Rio CLI provides an easy way to build and deploy your applications into a Kubernetes cluster. It takes advantage of Riofile and buildkit to build images and update deployments with them.","title":"Developing application using Rio"},{"location":"developing-application-using-rio/#using-riofile-to-develop-applications","text":"Let's use this repo as an example: Clone this repo. $ git clone https://github.com/ibuildthecloud/rancher-demo Go into the repo $ cd rancher-demo Create a Riofile in the root directory services : demo : image : ./ # By giving image a relative path, it tells rio to use this as build context port : 8080/http # defining ports to expose Run $ rio up Check with rio ps . It should create a service with URL serving the content. It should be serving blue cows. Open the Dockerfile and change ENV COW_COLOR from blue to red . Re-run rio up . Once it is finished, it should already be updated with new images and start serving red cows. By following the example above, you can now develop your code locally and run rio up to see your code changes automatically. Note : This feature requires a Dockerfile.","title":"Using Riofile to develop applications"},{"location":"developing-application-using-rio/#manually-build-and-run","text":"You can also use the Rio CLI to build and run an image locally in your cluster. Go to the root directory of repo and run $ rio build Wait for the image to be built. Once it is done, run $ rio images Run containers with images you just built $ rio run -p 8080 localhost:5442/default/rancher-demo:latest","title":"Manually build and run"},{"location":"faq/","text":"FAQs \u00b6 Frequently asked questions for Rio \u00b6 Q: What Kubernetes version do I need to run rio? A: We recommend using K3s ! Rio should work with any Kubernetes version v1.15+. If using a managed Kubernetes instance, use the latest version available. We have internally tested major features of Rio with GKE v1.14.8-gke.12 and EKS v1.14.8-eks-b7174d. \u00b6 Q: Why doesn't the first workload I create have a version but staged workloads do? A: The first workload you create is always v0 by default, and this is hidden in the CLI to avoid clutter. \u00b6 Q: Why is the Rio CLI stuck when I run a command? A: Verify you have used an available option and don't have any typos. If you are sure there are no typos in your command, feel free to submit an issue with the exact command and options you used. \u00b6 Q: How can I delete multiple workloads at once? A: Use a space to separate the services, routes, etc. Example: rio rm svc1 svc2 router/route1 externalservice/foo \u00b6 Q: Why can't I remove services that were created with a Riofile? A: If you wish to delete ALL resources associated to the stack, delete the stack itself: 1. Obtain the stack name: rio stacks 2. Delete it: rio rm <stack name> If instead you wish to remove a specific resource, then remove it from the Riofile and reapply it: rio up \u00b6 Q: How to configure custom domain instead of xxxxxx.on-rio.io? A: Rio allows you to configure multiple cluster domains that are generated for endpoint URL. By default you get ${namespace}-${name}.xxxxxx.on-rio.io if you have configured your own cluster domain you will get endpoint like: ${namespace}-${name}.you.company.com Run rio info . If you enabled rdns feature, you can take the cluster domain and create a CNAME record from your own wildcard domain to rio cluster domain. *.your.company.com -----> CNAME ------> xxx.on-rio.io If you disabled rdns feature, you won't be able to get xxxxxx.on-rio.io domain. Create A record from your domain to gateway IP. *.your.company.com -----> A ------> IP To get gateway IP run: bash kubectl get svc gateway-proxy -n rio-system -o jsonpath='{.status.loadBalancer.ingress[0].ip}' Also you are responsible for updating dns record if load balancer IP has changed. Create a wildcard TLS secret for your own domain. kubectl -n rio-system create secret tls your.company.com-tls --cert = /path/to/your.cert --key = /path/to/your.key Create a clusterDomain.yaml and kubectl apply -f ./clusterDomain.yaml apiVersion : admin.rio.cattle.io/v1 kind : ClusterDomain metadata : name : your.company.com spec : secretName : your.company.com-tls httpPort : 80 httpsPort : 443 Rio will serve your own wildcard domain and your own certs now.","title":"Troubleshooting"},{"location":"faq/#faqs","text":"Frequently asked questions for Rio","title":"FAQs"},{"location":"faq/#_1","text":"Q: What Kubernetes version do I need to run rio? A: We recommend using K3s ! Rio should work with any Kubernetes version v1.15+. If using a managed Kubernetes instance, use the latest version available. We have internally tested major features of Rio with GKE v1.14.8-gke.12 and EKS v1.14.8-eks-b7174d.","title":""},{"location":"faq/#_2","text":"Q: Why doesn't the first workload I create have a version but staged workloads do? A: The first workload you create is always v0 by default, and this is hidden in the CLI to avoid clutter.","title":""},{"location":"faq/#_3","text":"Q: Why is the Rio CLI stuck when I run a command? A: Verify you have used an available option and don't have any typos. If you are sure there are no typos in your command, feel free to submit an issue with the exact command and options you used.","title":""},{"location":"faq/#_4","text":"Q: How can I delete multiple workloads at once? A: Use a space to separate the services, routes, etc. Example: rio rm svc1 svc2 router/route1 externalservice/foo","title":""},{"location":"faq/#_5","text":"Q: Why can't I remove services that were created with a Riofile? A: If you wish to delete ALL resources associated to the stack, delete the stack itself: 1. Obtain the stack name: rio stacks 2. Delete it: rio rm <stack name> If instead you wish to remove a specific resource, then remove it from the Riofile and reapply it: rio up","title":""},{"location":"faq/#_6","text":"Q: How to configure custom domain instead of xxxxxx.on-rio.io? A: Rio allows you to configure multiple cluster domains that are generated for endpoint URL. By default you get ${namespace}-${name}.xxxxxx.on-rio.io if you have configured your own cluster domain you will get endpoint like: ${namespace}-${name}.you.company.com Run rio info . If you enabled rdns feature, you can take the cluster domain and create a CNAME record from your own wildcard domain to rio cluster domain. *.your.company.com -----> CNAME ------> xxx.on-rio.io If you disabled rdns feature, you won't be able to get xxxxxx.on-rio.io domain. Create A record from your domain to gateway IP. *.your.company.com -----> A ------> IP To get gateway IP run: bash kubectl get svc gateway-proxy -n rio-system -o jsonpath='{.status.loadBalancer.ingress[0].ip}' Also you are responsible for updating dns record if load balancer IP has changed. Create a wildcard TLS secret for your own domain. kubectl -n rio-system create secret tls your.company.com-tls --cert = /path/to/your.cert --key = /path/to/your.key Create a clusterDomain.yaml and kubectl apply -f ./clusterDomain.yaml apiVersion : admin.rio.cattle.io/v1 kind : ClusterDomain metadata : name : your.company.com spec : secretName : your.company.com-tls httpPort : 80 httpsPort : 443 Rio will serve your own wildcard domain and your own certs now.","title":""},{"location":"flows/","text":"Deployment Flows \u00b6 The following are the supported ways Rio can deploy a service and a service's future versions. There are many options beyond what is displayed here, for instance deploying from a branch, rollout duration, or using rio build. Functional params like port are omitted for brevity. Manual flows \u00b6 Image-only \u00b6 Run initial service: rio run -n demo imageV1 Action to update: rio stage --image imageV2 demo v2 Action to shift traffic: rio weight demo@v2=100 Automatic flows \u00b6 Flows below default to update-in-place. Use the --template flag to create an additional service each time from the original service template. Traffic will shift automatically, to disable this use --template and --stage-only params. See the cli-reference docs for more options, such as rollout duration. Build from source on commit - polling or webhook \u00b6 Run initial service: rio run -n demo https://github.com/rancher/rio-demo Action to update: Add a new commit to repo, for example merge a PR Build from source on tag - webhook-only \u00b6 Run initial service: rio run -n demo --build-tag --build-webhook-secret=secret https://github.com/rancher/rio-demo Action to update: Create a tag Additional flows \u00b6 Build-PR: spin up a new service for each PR opened on the repo. \u00b6 Run initial service: rio run -n demo --build-pr --template --build-webhook-secret=mysecret https://github.com/rancher/rio-demo Action to update: Create a new PR and a new service will be spun up. On PR merge or close, the PR service is removed.","title":"Deployment Flow"},{"location":"flows/#deployment-flows","text":"The following are the supported ways Rio can deploy a service and a service's future versions. There are many options beyond what is displayed here, for instance deploying from a branch, rollout duration, or using rio build. Functional params like port are omitted for brevity.","title":"Deployment Flows"},{"location":"flows/#manual-flows","text":"","title":"Manual flows"},{"location":"flows/#image-only","text":"Run initial service: rio run -n demo imageV1 Action to update: rio stage --image imageV2 demo v2 Action to shift traffic: rio weight demo@v2=100","title":"Image-only"},{"location":"flows/#automatic-flows","text":"Flows below default to update-in-place. Use the --template flag to create an additional service each time from the original service template. Traffic will shift automatically, to disable this use --template and --stage-only params. See the cli-reference docs for more options, such as rollout duration.","title":"Automatic flows"},{"location":"flows/#build-from-source-on-commit-polling-or-webhook","text":"Run initial service: rio run -n demo https://github.com/rancher/rio-demo Action to update: Add a new commit to repo, for example merge a PR","title":"Build from source on commit - polling or webhook"},{"location":"flows/#build-from-source-on-tag-webhook-only","text":"Run initial service: rio run -n demo --build-tag --build-webhook-secret=secret https://github.com/rancher/rio-demo Action to update: Create a tag","title":"Build from source on tag - webhook-only"},{"location":"flows/#additional-flows","text":"","title":"Additional flows"},{"location":"flows/#build-pr-spin-up-a-new-service-for-each-pr-opened-on-the-repo","text":"Run initial service: rio run -n demo --build-pr --template --build-webhook-secret=mysecret https://github.com/rancher/rio-demo Action to update: Create a new PR and a new service will be spun up. On PR merge or close, the PR service is removed.","title":"Build-PR: spin up a new service for each PR opened on the repo."},{"location":"install/","text":"Install Rio \u00b6 Table of Contents \u00b6 Intro Options Clusters & Providers Internal vs. External IP k3s EKS Features Autoscaling Build Gloo Linkerd Let's Encrypt RDNS Dashboard Example Disabling Features Example Enabling Features Introduction \u00b6 Rio can be installed from both the CLI or a Kubernetes manifest. Download the latest release. $ curl -sfL https://get.rio.io | sh - Note: by default the script will only download the latest release from GitHub. To test a pre-release or alpha build, run. $ curl -sfL https://get.rio.io | INSTALL_RIO_VERSION = ${ version } sh - Prepare a Kubernetes cluster, see Clusters and Providers . Set the KUBECONFIG environment variable to point to your Kubernetes cluster. Run $ rio install Note: to install Rio with a Kubernetes manifest, run rio install --yaml . It will print out the Kubernetes manifest instead of installing Rio directly, so that you can apply the manifest later. Options \u00b6 See the CLI install reference docs for complete list of options. To lower footprint of rio, use the disable-features flag. Just be aware that you are disabling features of Rio. Check here . Clusters and Providers \u00b6 A 1.15 or higher version of Kubernetes is recommended. See the Kubernetes getting started guide to help choose a cluster type. Internal vs external IP address \u00b6 Some cloud providers will use an internal IP address by default and Rio will use that for its cluster domain. You can override this during cluster setup by configuring external IP's, or by using a cloud-provider to setup a load balancer which will have an external IP. For an example of installing a cluster with a cloud provider on Linode using Rancher, see step #8 on this doc . K3s \u00b6 When installing a K3s cluster, use the --no-deploy traefik flag if you would like Rio to provision load balancing for you. If you would like to keep this for ingresses, you can disable Gloo when installing rio. EKS \u00b6 Ensure you are running enough nodes with proper instance types to allow for the Rio and Kubernetes systems to run at least 45 pods. See the docs to help determine proper sizes: Guide: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI Total limits: https://github.com/awslabs/amazon-eks-ami/blob/master/files/eni-max-pods.txt For example: you have a workload that requires 15 pods and you want to run 2 nodes. 15+45 is a 60 pod minimum requirement, so running 2 t3.large nodes (2*35=70) would be just enough. Features \u00b6 Rio contains several independent components that are responsible for different functions, including service mesh, source code to deployment, autoscaling and advanced API gateway. By default it will install the bare minimum components to allow for the most basic rio functionality, including running services and canary deployments. Autoscaling and Build features are not enabled by default during rio install , but are automatically enabled when a service is created that wants to use these, i.e rio run --scale 0-4 -p 8080 https://github.com/rancher/rio-demo . Linkerd is not enabled by default on clusters with less than 3GB of memory. See Flipping features after installation to learn how to enable this and other features. If you have limited capacities in your cluster and don't want enable some of features, you can disable features to make footprint of Rio smaller. Here is the list of features: Feature Description autoscaling Auto-scaling services based on in-flight requests build Rio Build, from source code to deployment gloo API gateway backed by gloo linkerd Linkerd service mesh letsencrypt Let's Encrypt rdns Acquire DNS from public Rancher DNS service dashboard Rio UI The core functionality of Rio includes Rio CLI UX and Riofile UX, which is built-in and doesn't rely on any of these features. Beside core functionality, here is a list of advanced features. Autoscaling \u00b6 Manages autoscaling services in Rio. It deploys a pod inside cluster, watches the autoscaling config for each service, and scrapes metrics from pods. It will then make decisions to scale pods up and down based on those real-time metrics and autoscaling configs. NOTE: The metrics are scraped from Linkerd, so if that feature is disabled, autoscaling will not work. Build \u00b6 Build is responsible for building images from source code, which allows you to run deployment directly from source code with a Dockerfile. Build is also responsible for setting up webhook to watch your source code change and trigger automatic builds. Gloo \u00b6 Gloo is the default API gateway Rio deploys to manage ingress traffic outside of cluster. It uses Envoy under the hood to provide rate limiting, circuit breaking, retries and other advanced routing features. Rio router programs Gloo virtualservices. Linkerd \u00b6 Linkerd is a service mesh for Kubernetes and other frameworks. It makes running services easier and safer by giving you runtime debugging, observability, reliability, and security\u2014all without requiring any changes to your code. By default Rio ships with Linkerd and enables its service mesh within Rio services Letsencrypt \u00b6 Letsencrypt is default CA that Rio uses to provision and sign certificates and use that to provide TLS traffic for your workloads. You easily swap certificates to your own certs. Under the hood it deploys cert-manager to manage certificate provisioning. Rdns \u00b6 Rdns is public DNS service hosted by Rancher. Each cluster with Rio installed will get a unique cluster domain (xxxxxx.on-rio.io). Rio registers this domain to Loadbalancer IP of API gateway service, which will eventually point to your service. Rdns will keep DNS record up-to-date if loadbalancer IP has changed. If you disabled this feature, you are responsible for updating your own DNS record if the loadbalancer IP changes. Dashboard \u00b6 Dashboard is a built-in web UI for Rio that runs within the cluster. It can be used as an alternative to the Rio CLI. Disabling Features on Install \u00b6 Note : If You have limited cpu and memory in your k8s cluster, we recommend you to disable features that you don't need in order to keep footprint of Rio smaller. To disable linkerd service mesh: $ rio install --disable-features linkerd If you would like to use your own cluster domain and certificates instead of rdns and letsencrypt, you can disable these two features: $ rio install --disable-features rdns,letsencrypt And follow docs in here to see how to bring your own cluster domain and certs. Flipping features after installation \u00b6 Rio manages features in a configMap called rio-config in rio-system namespace. It follows the format: { \"features\" : { \"autoscaling\" : { \"enabled\" : true }, \"build\" : { \"enabled\" : true }, \"dashboard\" : { \"enabled\" : true }, \"linkerd\" : { \"enabled\" : true , \"options\" : { \"upgrade\" : \"true\" } }, \"gloo\" : { \"enabled\" : true }, \"rdns\" : { \"enabled\" : true } }, \"letsEncrypt\" : { \"email\" : \"your@email.here\" }, \"gateway\" : { \"serviceName\" : \"gateway-proxy\" , \"serviceNamespace\" : \"rio-system\" } } To edit the configMap, run rio system feature --edit","title":"Install Rio"},{"location":"install/#install-rio","text":"","title":"Install Rio"},{"location":"install/#table-of-contents","text":"Intro Options Clusters & Providers Internal vs. External IP k3s EKS Features Autoscaling Build Gloo Linkerd Let's Encrypt RDNS Dashboard Example Disabling Features Example Enabling Features","title":"Table of Contents"},{"location":"install/#introduction","text":"Rio can be installed from both the CLI or a Kubernetes manifest. Download the latest release. $ curl -sfL https://get.rio.io | sh - Note: by default the script will only download the latest release from GitHub. To test a pre-release or alpha build, run. $ curl -sfL https://get.rio.io | INSTALL_RIO_VERSION = ${ version } sh - Prepare a Kubernetes cluster, see Clusters and Providers . Set the KUBECONFIG environment variable to point to your Kubernetes cluster. Run $ rio install Note: to install Rio with a Kubernetes manifest, run rio install --yaml . It will print out the Kubernetes manifest instead of installing Rio directly, so that you can apply the manifest later.","title":"Introduction"},{"location":"install/#options","text":"See the CLI install reference docs for complete list of options. To lower footprint of rio, use the disable-features flag. Just be aware that you are disabling features of Rio. Check here .","title":"Options"},{"location":"install/#clusters-and-providers","text":"A 1.15 or higher version of Kubernetes is recommended. See the Kubernetes getting started guide to help choose a cluster type.","title":"Clusters and Providers"},{"location":"install/#internal-vs-external-ip-address","text":"Some cloud providers will use an internal IP address by default and Rio will use that for its cluster domain. You can override this during cluster setup by configuring external IP's, or by using a cloud-provider to setup a load balancer which will have an external IP. For an example of installing a cluster with a cloud provider on Linode using Rancher, see step #8 on this doc .","title":"Internal vs external IP address"},{"location":"install/#k3s","text":"When installing a K3s cluster, use the --no-deploy traefik flag if you would like Rio to provision load balancing for you. If you would like to keep this for ingresses, you can disable Gloo when installing rio.","title":"K3s"},{"location":"install/#eks","text":"Ensure you are running enough nodes with proper instance types to allow for the Rio and Kubernetes systems to run at least 45 pods. See the docs to help determine proper sizes: Guide: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI Total limits: https://github.com/awslabs/amazon-eks-ami/blob/master/files/eni-max-pods.txt For example: you have a workload that requires 15 pods and you want to run 2 nodes. 15+45 is a 60 pod minimum requirement, so running 2 t3.large nodes (2*35=70) would be just enough.","title":"EKS"},{"location":"install/#features","text":"Rio contains several independent components that are responsible for different functions, including service mesh, source code to deployment, autoscaling and advanced API gateway. By default it will install the bare minimum components to allow for the most basic rio functionality, including running services and canary deployments. Autoscaling and Build features are not enabled by default during rio install , but are automatically enabled when a service is created that wants to use these, i.e rio run --scale 0-4 -p 8080 https://github.com/rancher/rio-demo . Linkerd is not enabled by default on clusters with less than 3GB of memory. See Flipping features after installation to learn how to enable this and other features. If you have limited capacities in your cluster and don't want enable some of features, you can disable features to make footprint of Rio smaller. Here is the list of features: Feature Description autoscaling Auto-scaling services based on in-flight requests build Rio Build, from source code to deployment gloo API gateway backed by gloo linkerd Linkerd service mesh letsencrypt Let's Encrypt rdns Acquire DNS from public Rancher DNS service dashboard Rio UI The core functionality of Rio includes Rio CLI UX and Riofile UX, which is built-in and doesn't rely on any of these features. Beside core functionality, here is a list of advanced features.","title":"Features"},{"location":"install/#autoscaling","text":"Manages autoscaling services in Rio. It deploys a pod inside cluster, watches the autoscaling config for each service, and scrapes metrics from pods. It will then make decisions to scale pods up and down based on those real-time metrics and autoscaling configs. NOTE: The metrics are scraped from Linkerd, so if that feature is disabled, autoscaling will not work.","title":"Autoscaling"},{"location":"install/#build","text":"Build is responsible for building images from source code, which allows you to run deployment directly from source code with a Dockerfile. Build is also responsible for setting up webhook to watch your source code change and trigger automatic builds.","title":"Build"},{"location":"install/#gloo","text":"Gloo is the default API gateway Rio deploys to manage ingress traffic outside of cluster. It uses Envoy under the hood to provide rate limiting, circuit breaking, retries and other advanced routing features. Rio router programs Gloo virtualservices.","title":"Gloo"},{"location":"install/#linkerd","text":"Linkerd is a service mesh for Kubernetes and other frameworks. It makes running services easier and safer by giving you runtime debugging, observability, reliability, and security\u2014all without requiring any changes to your code. By default Rio ships with Linkerd and enables its service mesh within Rio services","title":"Linkerd"},{"location":"install/#letsencrypt","text":"Letsencrypt is default CA that Rio uses to provision and sign certificates and use that to provide TLS traffic for your workloads. You easily swap certificates to your own certs. Under the hood it deploys cert-manager to manage certificate provisioning.","title":"Letsencrypt"},{"location":"install/#rdns","text":"Rdns is public DNS service hosted by Rancher. Each cluster with Rio installed will get a unique cluster domain (xxxxxx.on-rio.io). Rio registers this domain to Loadbalancer IP of API gateway service, which will eventually point to your service. Rdns will keep DNS record up-to-date if loadbalancer IP has changed. If you disabled this feature, you are responsible for updating your own DNS record if the loadbalancer IP changes.","title":"Rdns"},{"location":"install/#dashboard","text":"Dashboard is a built-in web UI for Rio that runs within the cluster. It can be used as an alternative to the Rio CLI.","title":"Dashboard"},{"location":"install/#disabling-features-on-install","text":"Note : If You have limited cpu and memory in your k8s cluster, we recommend you to disable features that you don't need in order to keep footprint of Rio smaller. To disable linkerd service mesh: $ rio install --disable-features linkerd If you would like to use your own cluster domain and certificates instead of rdns and letsencrypt, you can disable these two features: $ rio install --disable-features rdns,letsencrypt And follow docs in here to see how to bring your own cluster domain and certs.","title":"Disabling Features on Install"},{"location":"install/#flipping-features-after-installation","text":"Rio manages features in a configMap called rio-config in rio-system namespace. It follows the format: { \"features\" : { \"autoscaling\" : { \"enabled\" : true }, \"build\" : { \"enabled\" : true }, \"dashboard\" : { \"enabled\" : true }, \"linkerd\" : { \"enabled\" : true , \"options\" : { \"upgrade\" : \"true\" } }, \"gloo\" : { \"enabled\" : true }, \"rdns\" : { \"enabled\" : true } }, \"letsEncrypt\" : { \"email\" : \"your@email.here\" }, \"gateway\" : { \"serviceName\" : \"gateway-proxy\" , \"serviceNamespace\" : \"rio-system\" } } To edit the configMap, run rio system feature --edit","title":"Flipping features after installation"},{"location":"monitoring/","text":"Monitoring \u00b6 Rio deploys linkerd to collect metrics from workloads. You can use the Rio dashboard or linkerd dashboard to monitor traffic for your applications. To run Rio dashboard, check here . To run the linkerd dashboard: $ rio linkerd # if you have linkerd binary $ linkerd dashboard","title":"Monitoring Workloads"},{"location":"monitoring/#monitoring","text":"Rio deploys linkerd to collect metrics from workloads. You can use the Rio dashboard or linkerd dashboard to monitor traffic for your applications. To run Rio dashboard, check here . To run the linkerd dashboard: $ rio linkerd # if you have linkerd binary $ linkerd dashboard","title":"Monitoring"},{"location":"publicdomain-external-services/","text":"PublicDomain \u00b6 Rio allows you to add a vanity domain, such as www.myproductionsite.com , to your workloads. For example: If you enabled rdns feature, Setup a CNAME record from your domain to the Rio cluster domain. You should be able to see the cluster domain when running rio info . www.myproduction.com -----> CNAME -------> xxxxxx.on-rio.io If you disabled rdns feature, you won't be able to get xxxxxx.on-rio.io domain. Instead, create A record to IP of API gateway Get the ip of the service loadbalancer that points to API gateway kubectl get svc gateway-proxy -n rio-system -o jsonpath = '{.status.loadBalancer.ingress[0].ip}' Create DNS record www.myproduction.com -----> A -------> IP Register the domain in rio # Register a target service with the domain $ rio domain register myproductionsite.com $target # Access your domain $ rio endpoint You can provide your own certificates instead of using letsencrypt. To create a secret that contains your tls.crt and tls.key: kubectl -n rio-system create secret tls www.myproductionsite.com-tls --cert = /path/to/your.cert --key = /path/to/your.key Register domain with secret you just created $ rio domain register --secret www.myproductionsite.com-tls www.myproductionsite.com $target In the above example, $target can be a service( app@version ), a group of services( app ) or a router( router ) For example, to register a domain with app demo and version v1 : $ rio domain register myproductionsite.com demo@v1 To register a domain with app demo : $ rio domain register myproductionsite.com demo To register a domain with router prod : $ rio domain register myproductionsite.com router/prod To unregister a domain: $ rio domain unregister publicdomain/myproductionsite.com ExternalService \u00b6 ExternalService is a service such as a database or legacy app outside of your cluster. ExternalService can be specified with an IP addresses, FQDN, or a Rio service in another namespace. Once added, external services can be discovered by short name within the same namespace. To add externalservice ext pointing to FQDN $ rio external create ext mydb.address To add externalservice ext pointing to IP addresses $ rio external create ext 1 .1.1.1 2 .2.2.2 To add externalservice pointing to app demo and version v1 $ rio external create ext demo@v1 # to change the namespace $ rio external create ext foo:demo@v1 To add externalservice pointing to app demo $ rio external create ext demo To add externalservice pointing to route prod $ rio external create ext router/prod","title":"Configuring PublicDomain and ExternalService"},{"location":"publicdomain-external-services/#publicdomain","text":"Rio allows you to add a vanity domain, such as www.myproductionsite.com , to your workloads. For example: If you enabled rdns feature, Setup a CNAME record from your domain to the Rio cluster domain. You should be able to see the cluster domain when running rio info . www.myproduction.com -----> CNAME -------> xxxxxx.on-rio.io If you disabled rdns feature, you won't be able to get xxxxxx.on-rio.io domain. Instead, create A record to IP of API gateway Get the ip of the service loadbalancer that points to API gateway kubectl get svc gateway-proxy -n rio-system -o jsonpath = '{.status.loadBalancer.ingress[0].ip}' Create DNS record www.myproduction.com -----> A -------> IP Register the domain in rio # Register a target service with the domain $ rio domain register myproductionsite.com $target # Access your domain $ rio endpoint You can provide your own certificates instead of using letsencrypt. To create a secret that contains your tls.crt and tls.key: kubectl -n rio-system create secret tls www.myproductionsite.com-tls --cert = /path/to/your.cert --key = /path/to/your.key Register domain with secret you just created $ rio domain register --secret www.myproductionsite.com-tls www.myproductionsite.com $target In the above example, $target can be a service( app@version ), a group of services( app ) or a router( router ) For example, to register a domain with app demo and version v1 : $ rio domain register myproductionsite.com demo@v1 To register a domain with app demo : $ rio domain register myproductionsite.com demo To register a domain with router prod : $ rio domain register myproductionsite.com router/prod To unregister a domain: $ rio domain unregister publicdomain/myproductionsite.com","title":"PublicDomain"},{"location":"publicdomain-external-services/#externalservice","text":"ExternalService is a service such as a database or legacy app outside of your cluster. ExternalService can be specified with an IP addresses, FQDN, or a Rio service in another namespace. Once added, external services can be discovered by short name within the same namespace. To add externalservice ext pointing to FQDN $ rio external create ext mydb.address To add externalservice ext pointing to IP addresses $ rio external create ext 1 .1.1.1 2 .2.2.2 To add externalservice pointing to app demo and version v1 $ rio external create ext demo@v1 # to change the namespace $ rio external create ext foo:demo@v1 To add externalservice pointing to app demo $ rio external create ext demo To add externalservice pointing to route prod $ rio external create ext router/prod","title":"ExternalService"},{"location":"quick-start/","text":"Quick Start \u00b6 Exposing the service requires passing the -p flag to expose ports from the container Running a container from a Docker image \u00b6 $ rio run -p 80 --name demo nginx # You will get an endpoint URL for your service $ rio ps # Access endpoint URL curl https://demo-v0-default.xxxxx.on-rio.io Running a container from a GitHub repository \u00b6 Rio allows a user to run a container directly from source code. By pointing to git repository that contains a Dockerfile, Rio will clone the source code, build the Docker image, and deploy it into the cluster. Also Rio will watch for changes to the repo and automatically update the deployment. $ rio run -p 8080 --name demo-2 https://github.com/rancher/rio-demo # You will get an endpoint URL for your service $ rio ps # Access endpoint URL curl https://demo-2-v0-default.xxxxx.on-rio.io For more advanced use cases, check Running workload in Rio","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"Exposing the service requires passing the -p flag to expose ports from the container","title":"Quick Start"},{"location":"quick-start/#running-a-container-from-a-docker-image","text":"$ rio run -p 80 --name demo nginx # You will get an endpoint URL for your service $ rio ps # Access endpoint URL curl https://demo-v0-default.xxxxx.on-rio.io","title":"Running a container from a Docker image"},{"location":"quick-start/#running-a-container-from-a-github-repository","text":"Rio allows a user to run a container directly from source code. By pointing to git repository that contains a Dockerfile, Rio will clone the source code, build the Docker image, and deploy it into the cluster. Also Rio will watch for changes to the repo and automatically update the deployment. $ rio run -p 8080 --name demo-2 https://github.com/rancher/rio-demo # You will get an endpoint URL for your service $ rio ps # Access endpoint URL curl https://demo-2-v0-default.xxxxx.on-rio.io For more advanced use cases, check Running workload in Rio","title":"Running a container from a GitHub repository"},{"location":"rbac/","text":"RBAC \u00b6 Rio can be configured and used in a multi-tenant environment while providing the best practices for security. This section requires basic knowledge of Kubernetes RBAC. To learn more about RBAC, go here . By default Rio creates four roles rio-admin , rio-privileged , rio-readonly , rio-standard . Detailed permissions can be found in here . To create a binding from one of the roles to your user and group in default namespace: apiVersion : rbac.authorization.k8s.io/v1 # This role binding allows \"jane\" to have rio admin access in the \"default\" namespace. kind : RoleBinding metadata : name : rio-admin namespace : default subjects : - kind : User name : jane # Name is case sensitive apiGroup : rbac.authorization.k8s.io roleRef : kind : ClusterRole name : rio-admin apiGroup : rbac.authorization.k8s.io Note: Pre-defined roles are experimental and subject to change. Container security \u00b6 Rio by default restricts users without admin permissions from deploying containers with insecure parameters. This is done by implementing a validatingMutationWebhook . The following fields are protected by default: Enable and disable sidecar injection Privileged containers Hostpath Hostport HostNetworking To enable a user to have these permissions, the following verbs must be granted on a role that is bound with the user: rio-servicemesh rio-privileged rio-hostpath rio-hostport rio-hostnetwork For example, to create a role with permission to launch privileged containers: apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : namespace : default name : run-privileged rules : - apiGroups : [ \"rio.cattle.io\" ] resources : [ \"services\" ] verbs : [ \"create\" , \"update\" , \"delete\" , \"rio-privileged\" ] Then follow the previous example to bind the user to this role.","title":"Configuring Rio with RBAC"},{"location":"rbac/#rbac","text":"Rio can be configured and used in a multi-tenant environment while providing the best practices for security. This section requires basic knowledge of Kubernetes RBAC. To learn more about RBAC, go here . By default Rio creates four roles rio-admin , rio-privileged , rio-readonly , rio-standard . Detailed permissions can be found in here . To create a binding from one of the roles to your user and group in default namespace: apiVersion : rbac.authorization.k8s.io/v1 # This role binding allows \"jane\" to have rio admin access in the \"default\" namespace. kind : RoleBinding metadata : name : rio-admin namespace : default subjects : - kind : User name : jane # Name is case sensitive apiGroup : rbac.authorization.k8s.io roleRef : kind : ClusterRole name : rio-admin apiGroup : rbac.authorization.k8s.io Note: Pre-defined roles are experimental and subject to change.","title":"RBAC"},{"location":"rbac/#container-security","text":"Rio by default restricts users without admin permissions from deploying containers with insecure parameters. This is done by implementing a validatingMutationWebhook . The following fields are protected by default: Enable and disable sidecar injection Privileged containers Hostpath Hostport HostNetworking To enable a user to have these permissions, the following verbs must be granted on a role that is bound with the user: rio-servicemesh rio-privileged rio-hostpath rio-hostport rio-hostnetwork For example, to create a role with permission to launch privileged containers: apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : namespace : default name : run-privileged rules : - apiGroups : [ \"rio.cattle.io\" ] resources : [ \"services\" ] verbs : [ \"create\" , \"update\" , \"delete\" , \"rio-privileged\" ] Then follow the previous example to bind the user to this role.","title":"Container security"},{"location":"riofile/","text":"Riofile \u00b6 Table of Contents \u00b6 Intro Watching a Riofile Reference Templating Using answer file Using environment substitution Examples How to use Rio to deploy an application with arbitary YAML How to watch a repo Intro \u00b6 Rio works with standard Kubernetes YAML files. Rio additionally supports a more user-friendly docker-compose -style config file called Riofile . This allows you define rio services, routes, external services, configs, and secrets. For example, here is an nginx application: configs : conf : index.html : |- <!DOCTYPE html> <html> <body> <h1>Hello World</h1> </body> </html> services : nginx : image : nginx ports : - 80/http configs : - conf/index.html:/usr/share/nginx/html/index.html Once you have defined Riofile , simply run rio up . If you made any change to the Riofile , re-run rio up to pick up the change. To use a file not named \"Riofile\" use rio up -f nginx.yaml . Watching a Riofile \u00b6 You can setup Rio to watch for Riofile changes in a Github repository and deploy Riofile changes automatically. For example: $ rio up https://github.com/username/repo By default, Rio will poll the branch in 30 second intervals, but this can be configured to use a webhook instead. See Webhook docs for info. Riofile Reference \u00b6 # Configmap configs : config-foo : # specify name in the section key1 : |- # specify key and data in the section config1 key2 : |- config2 # Externalservices externalservices : foo : ipAddresses : # Pointing to external IP addresses - 1.1.1.1 - 2.2.2.2 fqdn : www.foo.bar # Pointing to fqdn service : $namespace/$name # Pointing to services in another namespace # Service services : service-foo : app : my-app # Specify app name. Defaults to service name. This is used to aggregate services that belongs to the same app. version : v0 # Specify the version of app this service represents. Defaults to v0. Displayed as app@version, unless version is v0 where it will be omitted. scale : 2 # Specify scale of the service, defaults to 1. Use this to have service come up with the specified number of pods. template : false # Set this service as a template to build service versions from instead of overwriting on each build, false by default. See https://github.com/rancher/rio/blob/master/docs/continuous-deployment.md#automatic-versioning weight : 80 # Percentage of weight assigned to this revision. Defaults to 100. annotations : # Set annotations for the deployment and pods foo : bar labels : # Set labels for the deployment and pods foo : bar # To enable autoscaling: autoscale : concurrency : 10 # specify concurrent request each pod can handle(soft limit, used to scale service) maxReplicas : 10 minReplicas : 1 # Traffic rollout config. Optional rollout : increment : 5 # traffic percentage increment(%) for each interval. interval : 2 # traffic increment interval(seconds). pause : false # whether to perform rollout or not # Container configuration image : nginx # Container image. Required if not setting build imagePullPolicy : always # Image pull policy. Options: (always/never/ifNotProsent), defaults to ifNotProsent. build : # Setting build parameters. Set if you want to build image from source repo : https://github.com/rancher/rio # Git repository to build. Required branch : master # Git repository branch. Required revision : v0.1.0 # Revision digest to build. If set, image will be built based on this revision. Otherwise it will take head revision in repo. Also if revision is not set, it will be served as the base revision to watch any change in repo and create new revision based changes from repo. args : # Build arguments to pass to buildkit https://docs.docker.com/engine/reference/builder/#understand-how-arg-and-from-interact. Optional - foo=bar dockerfile : Dockerfile # The name of Dockerfile to look for. This is the full path relative to the repo root. Defaults to `Dockerfile`. context : ./ # Docker build context. Defaults to . noCache : true # Build without cache. Defaults to false. imageName : myname/image:tag # Specify custom image name(excluding registry name). Default name: $namespace/name:$revision_digest pushRegistry : docker.io # Specify push registry. Example: docker.io, gcr.io. Defaults to localhost registry. pushRegistrySecretName : secretDocker # Specify secret name for pushing to docker registry. [link](#set-custom-build-arguments-and-docker-registry) stageOnly : true # If set, newly created revision will not get any traffic. Defaults to false. webhookSecretName : secretGithub # Specify the github secret name. Used to create Github webhook, the secret key has to be `accessToken` cloneSecretName : secretGit # Specify secret name for checking our git resources pr : true # Enable pull request feature. Defaults to false tag : false # Optionally enable to build off every tag release in the repo tagInclude : ^v # If tag is true, only use tags matching this pattern tagExclude : rc # If tag is true, exclude any tags with this pattern timeout : 10 # build timeout setting in seconds command : # Container entrypoint, not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. - echo args : # Arguments to the entrypoint. The docker image's CMD is used if this is not provided. - \"hello world\" workingDir : /home # Container working directory ports : # Container ports, format: `$(servicePort:)containerPort/protocol`. Required if user wants to expose service through gateway - 8080:80/http,web # Service port 8080 will be mapped to container port 80 with protocol http, named `web` - 8080/http,admin,internal=true # Service port 8080 will be mapped to container port 8080 with protocol http, named `admin`, internal port(will not be exposed through gateway) env : # Specify environment variable - POD_NAME=$(self/name) # Mapped to \"metadata.name\" # # \"self/name\": \"metadata.name\", # \"self/namespace\": \"metadata.namespace\", # \"self/labels\": \"metadata.labels\", # \"self/annotations\": \"metadata.annotations\", # \"self/node\": \"spec.nodeName\", # \"self/serviceAccount\": \"spec.serviceAccountName\", # \"self/hostIp\": \"status.hostIP\", # \"self/nodeIp\": \"status.hostIP\", # \"self/ip\": \"status.podIP\", # cpus : 100m # Cpu request, format 0.5 or 500m. 500m = 0.5 core. If not set, cpu request will not be set. https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/ memory : 100Mi # Memory request. 100Mi, available options. If not set, memory request will not be set. https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/ secrets : # Specify secret to mount. Format: `$name/$key:/path/to/file`. Secret has to be pre-created in the same namespace - foo/bar:/my/password configs : # Specify configmap to mount. Format: `$name/$key:/path/to/file`. - foo/bar:/my/config livenessProbe : # LivenessProbe setting. https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/ httpGet : path : /ping port : \"9997\" # port must be string initialDelaySeconds : 10 readinessProbe : # ReadinessProbe https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/ failureThreshold : 7 httpGet : path : /ready port : \"9997\" # port must be string stdin : true # Whether this container should allocate a buffer for stdin in the container runtime stdinOnce : true # Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. tty : true # Whether this container should allocate a TTY for itself runAsUser : 1000 # The UID to run the entrypoint of the container process. runAsGroup : 1000 # The GID to run the entrypoint of the container process readOnlyRootFilesystem : true # Whether this container has a read-only root filesystem privileged : true # Run container in privileged mode. nodeAffinity : # Describes node affinity scheduling rules for the pod. podAffinity : # Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). podAntiAffinity : # Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). hostAliases : # Hostname alias - ip : 127.0.0.1 hostnames : - example.com hostNetwork : true # Use host networking, defaults to False. If this option is set, the ports that will be used must be specified. imagePullSecrets : # Image pull secret https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod - secret1 - secret2 # Containers: Specify sidecars. Other options are available in container section above, this is limited example containers : - init : true # Init container name : my-init image : ubuntu args : - \"echo\" - \"hello world\" # Permission for service # # global_permissions: # - 'create,get,list certmanager.k8s.io/*' # # this will give workload abilities to **create, get, list** **all** resources in api group **certmanager.k8s.io**. # # If you want to hook up with an existing role: # # # global_permissions: # - 'role=cluster-admin' # # # - `permisions`: Specify current namespace permission of workload # # Example: # # permissions: # - 'create,get,list certmanager.k8s.io/*' # # # This will give workload abilities to **create, get, list** **all** resources in api group **certmanager.k8s.io** in **current** namespace. # # Example: # # permissions: # - 'create,get,list /node/proxy' # # This will give subresource for node/proxy # Optional, will created and mount serviceAccountToken into pods with corresponding permissions global_permissions : - 'create,get,list certmanager.k8s.io/*' permissions : - 'create,get,list certmanager.k8s.io/*' # Router routers : foo : routes : - match : # Match rules, the first rule matching an incoming request is used path : # Match path, can specify regxp, prefix or exact match exact : /v0 # prefix: /bar # regxp: /bar.* methods : - GET headers : - name : FOO value : regxp : /bar.* #prefix: /bar #exact: /bar to : # Specify destination - app : myapp version : v1 port : 80 namespace : default weight : 50 - app : myapp version : v2 port : 80 namespace : default weight : 50 redirect : # Specify redirect rule host : www.foo.bar path : /redirect rewrite : host : www.foo.bar path : /rewrite headers : # Header operations add : - name : foo value : bar set : - name : foo value : bar remove : - foo fault : percentage : 80 # Inject fault percentage(%) delayMillis : 100 # Adding delay before injecting fault (millseconds) abortHTTPStatus : 502 # Injecting http code mirror : # Sending mirror traffic app : q version : v0 namespace : default timeoutSeconds : 1 # Setting request timeout (milli-seconds) retry : attempts : 10 # Retry attempts timeoutSeconds : 1 # Retry timeout (milli-seconds) # Use Riofile's answer/question templating # When you define NAMESPACE and REVISION variables in questions section rio will automatically inject their values. template : goTemplate : true # use go templating envSubst : true # use ENV vars during templating questions : # now make some questions that we provide answers too - variable : FOO # This will be available with go templates in the field `.Values.FOO` description : \"Some question we want an answer to.\" # Supply arbitrary kubernetes manifest yaml kubernetes : manifest : |- apiVersion: apps/v1 kind: Deployment .... Templating \u00b6 Using answer file \u00b6 Rio allows the user to leverage an answer file to customize Riofile . Go template and envSubst can be used to apply answers. By default, the NAMESPACE and REVISION variables are available when defined in the template questions. Answer file is a yaml manifest with key-value pairs: FOO : BAR For example, to use go templating to apply a service when provided with the above answers file and running in the test namespace: Create Riofile {{ - if (and (eq .Values.NAMESPACE test) (eq .Values.FOO BAR)) }} services : demo : image : ibuildthecloud/demo:v1 ports : - 80 {{ - end }} template : goTemplate : true # use go templating envSubst : true # use ENV vars during templating questions : # now make some questions that we provide answers too - variable : FOO description : \"My custom thing\" - variable : NAMESPACE description : \"The namespace\" kubectl create namespace test cd /path/to/Riofile && rio -n test up --answers answers.yaml Rio also supports a bash style envsubst replacement, with the following format: ${var^} ${var^^} ${var,} ${var,,} ${var:position} ${var:position:length} ${var#substring} ${var##substring} ${var%substring} ${var%%substring} ${var/substring/replacement} ${var//substring/replacement} ${var/#substring/replacement} ${var/%substring/replacement} ${var=default} ${var:=default} ${var:-default} Using environment substitution \u00b6 services : demo : image : ibuilthecloud/demo:v1 env : - FOO=${FOO} - MYNAMESPACE=${NAMESPACE} template : goTemplate : true # use go templating envSubst : true # use ENV vars during templating questions : # now make some questions that we provide answers too - variable : FOO description : \"My custom thing\" Examples \u00b6 How to use Rio to deploy an application with arbitary YAML \u00b6 In this example we will see how to define both a normal Rio service and arbitary Kubernetes manifests and deploy both of these with Rio. Follow the quickstart to get Rio installed into your cluster and ensure the output of rio info looks similar to this: Rio Version : >= 0 . 6 . 0 Rio CLI Version : >= 0 . 6 . 0 Cluster Domain : enu90s . on - rio . io Cluster Domain IPs : < cluster domain ip > System Namespace : rio - system System Ready State : true Wildcard certificates : true System Components : gateway - v2 status : Ready rio - controller status : Ready First, lets use a Riofile to define a a basic Rio service. configs: conf: index.html: |- <!DOCTYPE html> < html > < body > < h1 > Hello World </ h1 > </ body > </ html > services: nginx: image: nginx ports: - 80/http configs: - conf/index.html:/usr/share/nginx/html/index.html Next, we can augment this service with the Kubernetes sample guestbook configs : conf : index.html : |- <!DOCTYPE html> <html> <body> <h1>Hello World</h1> </body> </html> services : nginx : image : nginx ports : - 80/http configs : - conf/index.html:/usr/share/nginx/html/index.html kubernetes : manifest : |- apiVersion: v1 kind: Service metadata: name: redis-master labels: app: redis tier: backend role: master spec: ports: - port: 6379 targetPort: 6379 selector: app: redis tier: backend role: master --- apiVersion: apps/v1 # for k8s versions before 1.9.0 use apps/v1beta2 and before 1.8.0 use extensions/v1beta1 kind: Deployment metadata: name: redis-master spec: selector: matchLabels: app: redis role: master tier: backend replicas: 1 template: metadata: labels: app: redis role: master tier: backend spec: containers: - name: master image: k8s.gcr.io/redis:e2e # or just image: redis resources: requests: cpu: 100m memory: 100Mi ports: - containerPort: 6379 --- apiVersion: v1 kind: Service metadata: name: redis-slave labels: app: redis tier: backend role: slave spec: ports: - port: 6379 selector: app: redis tier: backend role: slave --- apiVersion: apps/v1 # for k8s versions before 1.9.0 use apps/v1beta2 and before 1.8.0 use extensions/v1beta1 kind: Deployment metadata: name: redis-slave spec: selector: matchLabels: app: redis role: slave tier: backend replicas: 2 template: metadata: labels: app: redis role: slave tier: backend spec: containers: - name: slave image: gcr.io/google_samples/gb-redisslave:v1 resources: requests: cpu: 100m memory: 100Mi env: - name: GET_HOSTS_FROM value: dns # If your cluster config does not include a dns service, then to # instead access an environment variable to find the master # service's host, comment out the 'value: dns' line above, and # uncomment the line below: # value: env ports: - containerPort: 6379 --- apiVersion: v1 kind: Service metadata: name: frontend labels: app: guestbook tier: frontend spec: # if your cluster supports it, uncomment the following to automatically create # an external load-balanced IP for the frontend service. # type: LoadBalancer ports: - port: 80 selector: app: guestbook tier: frontend --- apiVersion: apps/v1 # for k8s versions before 1.9.0 use apps/v1beta2 and before 1.8.0 use extensions/v1beta1 kind: Deployment metadata: name: frontend spec: selector: matchLabels: app: guestbook tier: frontend replicas: 3 template: metadata: labels: app: guestbook tier: frontend spec: containers: - name: php-redis image: gcr.io/google-samples/gb-frontend:v4 resources: requests: cpu: 100m memory: 100Mi env: - name: GET_HOSTS_FROM value: dns # If your cluster config does not include a dns service, then to # instead access environment variables to find service host # info, comment out the 'value: dns' line above, and uncomment the # line below: # value: env ports: - containerPort: 80 Typically you would track your Riofile with some form of VCS but for now simply save it in a local directory. Next, run rio up in that directory. You can watch Rio service come up with rio ps and the Kubernetes deployments with kubectl get deployments -w . You can check that the sample service came up by going to the endpoint given by rio ps NAME IMAGE ENDPOINT SCALE APP VERSION WEIGHT CREATED DETAIL nginx nginx https://nginx-2c21baa1-default.enu90s.on-rio.io 1 nginx 2c21baa1 100% 4 hours ago We can use Rio to expose the service and provision a LetsEncrypt certificate for it. rio router add guestbook to frontend,port=80 This will create a route to the service and create an endpoint. rio endpoints NAME ENDPOINTS nginx https://nginx-default.enu90s.on-rio.io guestbook https://guestbook-default.enu90s.on-rio.io We can now access this endpoint over encrypted https! How to watch a repo \u00b6 namespace = something kubectl create namespace ${ namespace } # based on your situation, you may have application level secrets to be created # kubectl apply -f deployments/secrets # if you have a private git repo, docker registry, you can use the above approach or you can create them using rio itself # if you have build instructions and want to push to a private registry # rio secrets create --docker # since you wish to watch a repo for changes on the stack definition, rio must have the ability to create a webhook in your repository # rio secrets create --github-webhook # try rio secrets create --help to see other options. # make sure you pass --build-clone-secret gitcredential if you are having a private git repo # see a nodejs example here https://github.com/lucidprogrammer/rio-samples.git rio -n ${ namespace } up --name somename --push-registry-secret dockerconfig \\ --file deployments/my-stack.yaml --build-webhook-secret githubtoken \\ --answers deployments/values-my-stack.json https://github.com/lucidprogrammer/rio-samples.git # you should be able to see the autoscaling in action with the following hey -z 600s -c 60 endpointurlofweb1service template : goTemplate : true envSubst : true questions : - variable : NAMESPACE description : \"namespace to deploy to\" - variable : REVISION description : \"Current commit\" # make sure you respect the type of the variable used. - variable : MAX_SCALE type : \"int\" description : \"maximum scale number\" services : web1 : version : v0 weight : 100 stageOnly : false autoscale : concurrency : 10 maxReplicas : ${MAX_SCALE} minReplicas : 1 ports : - 80:3000/http env : - NAMESPACE=${NAMESPACE} # say you want to have a way to show the version/commit in your application. - REVISION=${REVISION} # let's say you want to access a super secret as env, you may do as follows # - REDIS_PASSWORD=secret://spec/REDIS_PASSWORD build : branch : master context : ./src/web1 pushRegistry : docker.io # everytime you do a push to the repo, REVISION will match the specific commit hash and an image is created and pushed. imageName : lucidprogrammer/web1:${REVISION} # an example to use init containers web2 : version : v0 weight : 100 ports : - 80:80/http image : nginx:alpine volumes : - name : html path : /usr/share/nginx/html containers : - init : true name : web2-init image : busybox volumes : - name : html path : /work-dir command : - wget - \"-O\" - \"/work-dir/index.html\" - http://kubernetes.io","title":"Using Riofile"},{"location":"riofile/#riofile","text":"","title":"Riofile"},{"location":"riofile/#table-of-contents","text":"Intro Watching a Riofile Reference Templating Using answer file Using environment substitution Examples How to use Rio to deploy an application with arbitary YAML How to watch a repo","title":"Table of Contents"},{"location":"riofile/#intro","text":"Rio works with standard Kubernetes YAML files. Rio additionally supports a more user-friendly docker-compose -style config file called Riofile . This allows you define rio services, routes, external services, configs, and secrets. For example, here is an nginx application: configs : conf : index.html : |- <!DOCTYPE html> <html> <body> <h1>Hello World</h1> </body> </html> services : nginx : image : nginx ports : - 80/http configs : - conf/index.html:/usr/share/nginx/html/index.html Once you have defined Riofile , simply run rio up . If you made any change to the Riofile , re-run rio up to pick up the change. To use a file not named \"Riofile\" use rio up -f nginx.yaml .","title":"Intro"},{"location":"riofile/#watching-a-riofile","text":"You can setup Rio to watch for Riofile changes in a Github repository and deploy Riofile changes automatically. For example: $ rio up https://github.com/username/repo By default, Rio will poll the branch in 30 second intervals, but this can be configured to use a webhook instead. See Webhook docs for info.","title":"Watching a Riofile"},{"location":"riofile/#riofile-reference","text":"# Configmap configs : config-foo : # specify name in the section key1 : |- # specify key and data in the section config1 key2 : |- config2 # Externalservices externalservices : foo : ipAddresses : # Pointing to external IP addresses - 1.1.1.1 - 2.2.2.2 fqdn : www.foo.bar # Pointing to fqdn service : $namespace/$name # Pointing to services in another namespace # Service services : service-foo : app : my-app # Specify app name. Defaults to service name. This is used to aggregate services that belongs to the same app. version : v0 # Specify the version of app this service represents. Defaults to v0. Displayed as app@version, unless version is v0 where it will be omitted. scale : 2 # Specify scale of the service, defaults to 1. Use this to have service come up with the specified number of pods. template : false # Set this service as a template to build service versions from instead of overwriting on each build, false by default. See https://github.com/rancher/rio/blob/master/docs/continuous-deployment.md#automatic-versioning weight : 80 # Percentage of weight assigned to this revision. Defaults to 100. annotations : # Set annotations for the deployment and pods foo : bar labels : # Set labels for the deployment and pods foo : bar # To enable autoscaling: autoscale : concurrency : 10 # specify concurrent request each pod can handle(soft limit, used to scale service) maxReplicas : 10 minReplicas : 1 # Traffic rollout config. Optional rollout : increment : 5 # traffic percentage increment(%) for each interval. interval : 2 # traffic increment interval(seconds). pause : false # whether to perform rollout or not # Container configuration image : nginx # Container image. Required if not setting build imagePullPolicy : always # Image pull policy. Options: (always/never/ifNotProsent), defaults to ifNotProsent. build : # Setting build parameters. Set if you want to build image from source repo : https://github.com/rancher/rio # Git repository to build. Required branch : master # Git repository branch. Required revision : v0.1.0 # Revision digest to build. If set, image will be built based on this revision. Otherwise it will take head revision in repo. Also if revision is not set, it will be served as the base revision to watch any change in repo and create new revision based changes from repo. args : # Build arguments to pass to buildkit https://docs.docker.com/engine/reference/builder/#understand-how-arg-and-from-interact. Optional - foo=bar dockerfile : Dockerfile # The name of Dockerfile to look for. This is the full path relative to the repo root. Defaults to `Dockerfile`. context : ./ # Docker build context. Defaults to . noCache : true # Build without cache. Defaults to false. imageName : myname/image:tag # Specify custom image name(excluding registry name). Default name: $namespace/name:$revision_digest pushRegistry : docker.io # Specify push registry. Example: docker.io, gcr.io. Defaults to localhost registry. pushRegistrySecretName : secretDocker # Specify secret name for pushing to docker registry. [link](#set-custom-build-arguments-and-docker-registry) stageOnly : true # If set, newly created revision will not get any traffic. Defaults to false. webhookSecretName : secretGithub # Specify the github secret name. Used to create Github webhook, the secret key has to be `accessToken` cloneSecretName : secretGit # Specify secret name for checking our git resources pr : true # Enable pull request feature. Defaults to false tag : false # Optionally enable to build off every tag release in the repo tagInclude : ^v # If tag is true, only use tags matching this pattern tagExclude : rc # If tag is true, exclude any tags with this pattern timeout : 10 # build timeout setting in seconds command : # Container entrypoint, not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. - echo args : # Arguments to the entrypoint. The docker image's CMD is used if this is not provided. - \"hello world\" workingDir : /home # Container working directory ports : # Container ports, format: `$(servicePort:)containerPort/protocol`. Required if user wants to expose service through gateway - 8080:80/http,web # Service port 8080 will be mapped to container port 80 with protocol http, named `web` - 8080/http,admin,internal=true # Service port 8080 will be mapped to container port 8080 with protocol http, named `admin`, internal port(will not be exposed through gateway) env : # Specify environment variable - POD_NAME=$(self/name) # Mapped to \"metadata.name\" # # \"self/name\": \"metadata.name\", # \"self/namespace\": \"metadata.namespace\", # \"self/labels\": \"metadata.labels\", # \"self/annotations\": \"metadata.annotations\", # \"self/node\": \"spec.nodeName\", # \"self/serviceAccount\": \"spec.serviceAccountName\", # \"self/hostIp\": \"status.hostIP\", # \"self/nodeIp\": \"status.hostIP\", # \"self/ip\": \"status.podIP\", # cpus : 100m # Cpu request, format 0.5 or 500m. 500m = 0.5 core. If not set, cpu request will not be set. https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/ memory : 100Mi # Memory request. 100Mi, available options. If not set, memory request will not be set. https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/ secrets : # Specify secret to mount. Format: `$name/$key:/path/to/file`. Secret has to be pre-created in the same namespace - foo/bar:/my/password configs : # Specify configmap to mount. Format: `$name/$key:/path/to/file`. - foo/bar:/my/config livenessProbe : # LivenessProbe setting. https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/ httpGet : path : /ping port : \"9997\" # port must be string initialDelaySeconds : 10 readinessProbe : # ReadinessProbe https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/ failureThreshold : 7 httpGet : path : /ready port : \"9997\" # port must be string stdin : true # Whether this container should allocate a buffer for stdin in the container runtime stdinOnce : true # Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. tty : true # Whether this container should allocate a TTY for itself runAsUser : 1000 # The UID to run the entrypoint of the container process. runAsGroup : 1000 # The GID to run the entrypoint of the container process readOnlyRootFilesystem : true # Whether this container has a read-only root filesystem privileged : true # Run container in privileged mode. nodeAffinity : # Describes node affinity scheduling rules for the pod. podAffinity : # Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). podAntiAffinity : # Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). hostAliases : # Hostname alias - ip : 127.0.0.1 hostnames : - example.com hostNetwork : true # Use host networking, defaults to False. If this option is set, the ports that will be used must be specified. imagePullSecrets : # Image pull secret https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod - secret1 - secret2 # Containers: Specify sidecars. Other options are available in container section above, this is limited example containers : - init : true # Init container name : my-init image : ubuntu args : - \"echo\" - \"hello world\" # Permission for service # # global_permissions: # - 'create,get,list certmanager.k8s.io/*' # # this will give workload abilities to **create, get, list** **all** resources in api group **certmanager.k8s.io**. # # If you want to hook up with an existing role: # # # global_permissions: # - 'role=cluster-admin' # # # - `permisions`: Specify current namespace permission of workload # # Example: # # permissions: # - 'create,get,list certmanager.k8s.io/*' # # # This will give workload abilities to **create, get, list** **all** resources in api group **certmanager.k8s.io** in **current** namespace. # # Example: # # permissions: # - 'create,get,list /node/proxy' # # This will give subresource for node/proxy # Optional, will created and mount serviceAccountToken into pods with corresponding permissions global_permissions : - 'create,get,list certmanager.k8s.io/*' permissions : - 'create,get,list certmanager.k8s.io/*' # Router routers : foo : routes : - match : # Match rules, the first rule matching an incoming request is used path : # Match path, can specify regxp, prefix or exact match exact : /v0 # prefix: /bar # regxp: /bar.* methods : - GET headers : - name : FOO value : regxp : /bar.* #prefix: /bar #exact: /bar to : # Specify destination - app : myapp version : v1 port : 80 namespace : default weight : 50 - app : myapp version : v2 port : 80 namespace : default weight : 50 redirect : # Specify redirect rule host : www.foo.bar path : /redirect rewrite : host : www.foo.bar path : /rewrite headers : # Header operations add : - name : foo value : bar set : - name : foo value : bar remove : - foo fault : percentage : 80 # Inject fault percentage(%) delayMillis : 100 # Adding delay before injecting fault (millseconds) abortHTTPStatus : 502 # Injecting http code mirror : # Sending mirror traffic app : q version : v0 namespace : default timeoutSeconds : 1 # Setting request timeout (milli-seconds) retry : attempts : 10 # Retry attempts timeoutSeconds : 1 # Retry timeout (milli-seconds) # Use Riofile's answer/question templating # When you define NAMESPACE and REVISION variables in questions section rio will automatically inject their values. template : goTemplate : true # use go templating envSubst : true # use ENV vars during templating questions : # now make some questions that we provide answers too - variable : FOO # This will be available with go templates in the field `.Values.FOO` description : \"Some question we want an answer to.\" # Supply arbitrary kubernetes manifest yaml kubernetes : manifest : |- apiVersion: apps/v1 kind: Deployment ....","title":"Riofile Reference"},{"location":"riofile/#templating","text":"","title":"Templating"},{"location":"riofile/#using-answer-file","text":"Rio allows the user to leverage an answer file to customize Riofile . Go template and envSubst can be used to apply answers. By default, the NAMESPACE and REVISION variables are available when defined in the template questions. Answer file is a yaml manifest with key-value pairs: FOO : BAR For example, to use go templating to apply a service when provided with the above answers file and running in the test namespace: Create Riofile {{ - if (and (eq .Values.NAMESPACE test) (eq .Values.FOO BAR)) }} services : demo : image : ibuildthecloud/demo:v1 ports : - 80 {{ - end }} template : goTemplate : true # use go templating envSubst : true # use ENV vars during templating questions : # now make some questions that we provide answers too - variable : FOO description : \"My custom thing\" - variable : NAMESPACE description : \"The namespace\" kubectl create namespace test cd /path/to/Riofile && rio -n test up --answers answers.yaml Rio also supports a bash style envsubst replacement, with the following format: ${var^} ${var^^} ${var,} ${var,,} ${var:position} ${var:position:length} ${var#substring} ${var##substring} ${var%substring} ${var%%substring} ${var/substring/replacement} ${var//substring/replacement} ${var/#substring/replacement} ${var/%substring/replacement} ${var=default} ${var:=default} ${var:-default}","title":"Using answer file"},{"location":"riofile/#using-environment-substitution","text":"services : demo : image : ibuilthecloud/demo:v1 env : - FOO=${FOO} - MYNAMESPACE=${NAMESPACE} template : goTemplate : true # use go templating envSubst : true # use ENV vars during templating questions : # now make some questions that we provide answers too - variable : FOO description : \"My custom thing\"","title":"Using environment substitution"},{"location":"riofile/#examples","text":"","title":"Examples"},{"location":"riofile/#how-to-use-rio-to-deploy-an-application-with-arbitary-yaml","text":"In this example we will see how to define both a normal Rio service and arbitary Kubernetes manifests and deploy both of these with Rio. Follow the quickstart to get Rio installed into your cluster and ensure the output of rio info looks similar to this: Rio Version : >= 0 . 6 . 0 Rio CLI Version : >= 0 . 6 . 0 Cluster Domain : enu90s . on - rio . io Cluster Domain IPs : < cluster domain ip > System Namespace : rio - system System Ready State : true Wildcard certificates : true System Components : gateway - v2 status : Ready rio - controller status : Ready First, lets use a Riofile to define a a basic Rio service. configs: conf: index.html: |- <!DOCTYPE html> < html > < body > < h1 > Hello World </ h1 > </ body > </ html > services: nginx: image: nginx ports: - 80/http configs: - conf/index.html:/usr/share/nginx/html/index.html Next, we can augment this service with the Kubernetes sample guestbook configs : conf : index.html : |- <!DOCTYPE html> <html> <body> <h1>Hello World</h1> </body> </html> services : nginx : image : nginx ports : - 80/http configs : - conf/index.html:/usr/share/nginx/html/index.html kubernetes : manifest : |- apiVersion: v1 kind: Service metadata: name: redis-master labels: app: redis tier: backend role: master spec: ports: - port: 6379 targetPort: 6379 selector: app: redis tier: backend role: master --- apiVersion: apps/v1 # for k8s versions before 1.9.0 use apps/v1beta2 and before 1.8.0 use extensions/v1beta1 kind: Deployment metadata: name: redis-master spec: selector: matchLabels: app: redis role: master tier: backend replicas: 1 template: metadata: labels: app: redis role: master tier: backend spec: containers: - name: master image: k8s.gcr.io/redis:e2e # or just image: redis resources: requests: cpu: 100m memory: 100Mi ports: - containerPort: 6379 --- apiVersion: v1 kind: Service metadata: name: redis-slave labels: app: redis tier: backend role: slave spec: ports: - port: 6379 selector: app: redis tier: backend role: slave --- apiVersion: apps/v1 # for k8s versions before 1.9.0 use apps/v1beta2 and before 1.8.0 use extensions/v1beta1 kind: Deployment metadata: name: redis-slave spec: selector: matchLabels: app: redis role: slave tier: backend replicas: 2 template: metadata: labels: app: redis role: slave tier: backend spec: containers: - name: slave image: gcr.io/google_samples/gb-redisslave:v1 resources: requests: cpu: 100m memory: 100Mi env: - name: GET_HOSTS_FROM value: dns # If your cluster config does not include a dns service, then to # instead access an environment variable to find the master # service's host, comment out the 'value: dns' line above, and # uncomment the line below: # value: env ports: - containerPort: 6379 --- apiVersion: v1 kind: Service metadata: name: frontend labels: app: guestbook tier: frontend spec: # if your cluster supports it, uncomment the following to automatically create # an external load-balanced IP for the frontend service. # type: LoadBalancer ports: - port: 80 selector: app: guestbook tier: frontend --- apiVersion: apps/v1 # for k8s versions before 1.9.0 use apps/v1beta2 and before 1.8.0 use extensions/v1beta1 kind: Deployment metadata: name: frontend spec: selector: matchLabels: app: guestbook tier: frontend replicas: 3 template: metadata: labels: app: guestbook tier: frontend spec: containers: - name: php-redis image: gcr.io/google-samples/gb-frontend:v4 resources: requests: cpu: 100m memory: 100Mi env: - name: GET_HOSTS_FROM value: dns # If your cluster config does not include a dns service, then to # instead access environment variables to find service host # info, comment out the 'value: dns' line above, and uncomment the # line below: # value: env ports: - containerPort: 80 Typically you would track your Riofile with some form of VCS but for now simply save it in a local directory. Next, run rio up in that directory. You can watch Rio service come up with rio ps and the Kubernetes deployments with kubectl get deployments -w . You can check that the sample service came up by going to the endpoint given by rio ps NAME IMAGE ENDPOINT SCALE APP VERSION WEIGHT CREATED DETAIL nginx nginx https://nginx-2c21baa1-default.enu90s.on-rio.io 1 nginx 2c21baa1 100% 4 hours ago We can use Rio to expose the service and provision a LetsEncrypt certificate for it. rio router add guestbook to frontend,port=80 This will create a route to the service and create an endpoint. rio endpoints NAME ENDPOINTS nginx https://nginx-default.enu90s.on-rio.io guestbook https://guestbook-default.enu90s.on-rio.io We can now access this endpoint over encrypted https!","title":"How to use Rio to deploy an application with arbitary YAML"},{"location":"riofile/#how-to-watch-a-repo","text":"namespace = something kubectl create namespace ${ namespace } # based on your situation, you may have application level secrets to be created # kubectl apply -f deployments/secrets # if you have a private git repo, docker registry, you can use the above approach or you can create them using rio itself # if you have build instructions and want to push to a private registry # rio secrets create --docker # since you wish to watch a repo for changes on the stack definition, rio must have the ability to create a webhook in your repository # rio secrets create --github-webhook # try rio secrets create --help to see other options. # make sure you pass --build-clone-secret gitcredential if you are having a private git repo # see a nodejs example here https://github.com/lucidprogrammer/rio-samples.git rio -n ${ namespace } up --name somename --push-registry-secret dockerconfig \\ --file deployments/my-stack.yaml --build-webhook-secret githubtoken \\ --answers deployments/values-my-stack.json https://github.com/lucidprogrammer/rio-samples.git # you should be able to see the autoscaling in action with the following hey -z 600s -c 60 endpointurlofweb1service template : goTemplate : true envSubst : true questions : - variable : NAMESPACE description : \"namespace to deploy to\" - variable : REVISION description : \"Current commit\" # make sure you respect the type of the variable used. - variable : MAX_SCALE type : \"int\" description : \"maximum scale number\" services : web1 : version : v0 weight : 100 stageOnly : false autoscale : concurrency : 10 maxReplicas : ${MAX_SCALE} minReplicas : 1 ports : - 80:3000/http env : - NAMESPACE=${NAMESPACE} # say you want to have a way to show the version/commit in your application. - REVISION=${REVISION} # let's say you want to access a super secret as env, you may do as follows # - REDIS_PASSWORD=secret://spec/REDIS_PASSWORD build : branch : master context : ./src/web1 pushRegistry : docker.io # everytime you do a push to the repo, REVISION will match the specific commit hash and an image is created and pushed. imageName : lucidprogrammer/web1:${REVISION} # an example to use init containers web2 : version : v0 weight : 100 ports : - 80:80/http image : nginx:alpine volumes : - name : html path : /usr/share/nginx/html containers : - init : true name : web2-init image : busybox volumes : - name : html path : /work-dir command : - wget - \"-O\" - \"/work-dir/index.html\" - http://kubernetes.io","title":"How to watch a repo"},{"location":"router/","text":"Configuring Router \u00b6 Router is a set of L7 load-balancing rules that can route between your services. It can add header-based routing, path-based routing, cookies, and other rules. Routing uses the Gloo feature under the hood, so ensure that is enabled before continuing! See Install Docs to learn how to enable this feature. It will be enabled by default. Create Routers \u00b6 To create a router: $ rio [ -n $namespace ] route add $name to $target Note: $name will be the router name. $target can point to individual services or a group of services. The target service has to be in the same namespace as the router. For example, to point to app demo and version v1 : $ rio route add prod to demo@v1 To point to all weighted versions of app demo : $ rio route add prod to demo \u00b6 Add Path-Based Match \u00b6 Creating a route with path-based matching supports: exact match: foo ; prefix match: foo* ; and regular expression match: regexp(foo.*) . $ rio route add $name /path to $target # to add prefix $ rio route add $name /path '*' to $target # to add regular expression match $ rio route add $name /regexp '(foo[1-9])' to $target Try to access the routes you just created to test if routes are configured properly $ curl https://route.xxx.on-rio.io/path $ curl https://route.xxx.on-rio.io/path-test $ curl https://route.xxx.on-rio.io/foo1 \u00b6 Point to Different Port \u00b6 Create a route to a different port: $ rio route add $name to $target ,port = 8080 \u00b6 Add Header-Based Route \u00b6 Creating a route with header-based matching supports: exact match: foo ; prefix match: foo* ; and regular expression match: regexp(foo.*) . $ rio route add --header USER = test $name to $target $ rio route add --header USER = test '*' $name to $target $ rio route add --header USER = regexp '(test[1-9])' $name to $target Access url to test if routes are configured properly $ curl -H 'USER: test' https://route.xxx.on-rio.io $ curl -H 'USER: test-foo' https://route.xxx.on-rio.io $ curl -H 'USER: test1' https://route.xxx.on-rio.io \u00b6 Route Based on HTTP Method \u00b6 Create route based on HTTP method: $ rio route add --method POST $name to $target Sending POST requests to get traffic go through. Instead, GET request will get 404. $ curl -i -X POST https://route.xxx.on-rio.io $ curl -i -X GET https://route.xxx.on-rio.io \u00b6 Manipulate headers \u00b6 Add, set, or remove headers: $ rio route add --add-header FOO = BAR $name to $target $ rio route add --set-header FOO = BAR $name to $target $ rio route add --remove-header FOO = BAR $name to $target \u00b6 Rewrite to host/path \u00b6 Rewrite host header and path: $ rio route add --rewrite-host foo $name to $target $ rio route add --rewrite-path /path $name to $target \u00b6 Redirect \u00b6 Redirect to another service: $ rio route add $name redirect $target_service /path To add a https redirect $ rio route add --https-redirect $name to $target If you want to https redirect on your public domain, register domain to this router $ rio domain add foo.bar $name \u00b6 Timeout \u00b6 Add timeout: $ rio route add --timeout-seconds $value $name to $target \u00b6 Fault injection \u00b6 Add fault injection: $ rio route add --fault-httpcode 502 --fault-delay-milli-seconds 1000 --fault-percentage 80 $name to $target \u00b6 Retry logic \u00b6 Add retry logic: $ rio route add --retry-attempts 5 --retry-timeout-seconds 1 $name to $target \u00b6 Split traffic in router \u00b6 Create router to different revision and different weight: $ rio route add $name to $service @v0,weight = 50 $service @v1,weight = 50 \u00b6 Insert Rules \u00b6 Insert a router rule instead of append so that it will be evaluated first: $ rio route add --insert $name to $target","title":"Configuring Router"},{"location":"router/#configuring-router","text":"Router is a set of L7 load-balancing rules that can route between your services. It can add header-based routing, path-based routing, cookies, and other rules. Routing uses the Gloo feature under the hood, so ensure that is enabled before continuing! See Install Docs to learn how to enable this feature. It will be enabled by default.","title":"Configuring Router"},{"location":"router/#create-routers","text":"To create a router: $ rio [ -n $namespace ] route add $name to $target Note: $name will be the router name. $target can point to individual services or a group of services. The target service has to be in the same namespace as the router. For example, to point to app demo and version v1 : $ rio route add prod to demo@v1 To point to all weighted versions of app demo : $ rio route add prod to demo","title":"Create Routers"},{"location":"router/#_1","text":"","title":""},{"location":"router/#add-path-based-match","text":"Creating a route with path-based matching supports: exact match: foo ; prefix match: foo* ; and regular expression match: regexp(foo.*) . $ rio route add $name /path to $target # to add prefix $ rio route add $name /path '*' to $target # to add regular expression match $ rio route add $name /regexp '(foo[1-9])' to $target Try to access the routes you just created to test if routes are configured properly $ curl https://route.xxx.on-rio.io/path $ curl https://route.xxx.on-rio.io/path-test $ curl https://route.xxx.on-rio.io/foo1","title":"Add Path-Based Match"},{"location":"router/#_2","text":"","title":""},{"location":"router/#point-to-different-port","text":"Create a route to a different port: $ rio route add $name to $target ,port = 8080","title":"Point to Different Port"},{"location":"router/#_3","text":"","title":""},{"location":"router/#add-header-based-route","text":"Creating a route with header-based matching supports: exact match: foo ; prefix match: foo* ; and regular expression match: regexp(foo.*) . $ rio route add --header USER = test $name to $target $ rio route add --header USER = test '*' $name to $target $ rio route add --header USER = regexp '(test[1-9])' $name to $target Access url to test if routes are configured properly $ curl -H 'USER: test' https://route.xxx.on-rio.io $ curl -H 'USER: test-foo' https://route.xxx.on-rio.io $ curl -H 'USER: test1' https://route.xxx.on-rio.io","title":"Add Header-Based Route"},{"location":"router/#_4","text":"","title":""},{"location":"router/#route-based-on-http-method","text":"Create route based on HTTP method: $ rio route add --method POST $name to $target Sending POST requests to get traffic go through. Instead, GET request will get 404. $ curl -i -X POST https://route.xxx.on-rio.io $ curl -i -X GET https://route.xxx.on-rio.io","title":"Route Based on HTTP Method"},{"location":"router/#_5","text":"","title":""},{"location":"router/#manipulate-headers","text":"Add, set, or remove headers: $ rio route add --add-header FOO = BAR $name to $target $ rio route add --set-header FOO = BAR $name to $target $ rio route add --remove-header FOO = BAR $name to $target","title":"Manipulate headers"},{"location":"router/#_6","text":"","title":""},{"location":"router/#rewrite-to-hostpath","text":"Rewrite host header and path: $ rio route add --rewrite-host foo $name to $target $ rio route add --rewrite-path /path $name to $target","title":"Rewrite to host/path"},{"location":"router/#_7","text":"","title":""},{"location":"router/#redirect","text":"Redirect to another service: $ rio route add $name redirect $target_service /path To add a https redirect $ rio route add --https-redirect $name to $target If you want to https redirect on your public domain, register domain to this router $ rio domain add foo.bar $name","title":"Redirect"},{"location":"router/#_8","text":"","title":""},{"location":"router/#timeout","text":"Add timeout: $ rio route add --timeout-seconds $value $name to $target","title":"Timeout"},{"location":"router/#_9","text":"","title":""},{"location":"router/#fault-injection","text":"Add fault injection: $ rio route add --fault-httpcode 502 --fault-delay-milli-seconds 1000 --fault-percentage 80 $name to $target","title":"Fault injection"},{"location":"router/#_10","text":"","title":""},{"location":"router/#retry-logic","text":"Add retry logic: $ rio route add --retry-attempts 5 --retry-timeout-seconds 1 $name to $target","title":"Retry logic"},{"location":"router/#_11","text":"","title":""},{"location":"router/#split-traffic-in-router","text":"Create router to different revision and different weight: $ rio route add $name to $service @v0,weight = 50 $service @v1,weight = 50","title":"Split traffic in router"},{"location":"router/#_12","text":"","title":""},{"location":"router/#insert-rules","text":"Insert a router rule instead of append so that it will be evaluated first: $ rio route add --insert $name to $target","title":"Insert Rules"},{"location":"webhooks/","text":"Webhook \u00b6 By default, Rio will automatically poll the git repo and check if code has changed. You can also configure a webhook to automatically push any events to Rio to trigger the build. Note: Webhooks are currently only supported with Github. Set up the GitHub webhook token. $ rio secret add -- github - webhook Select namespace [ default ] : $ ( put the same namespace with your workload ) accessToken : $ ( github_accesstoken ) # the token has to be able create webhook in your github repo . Create workload and point to your repo . Create a workload and point to your repo rio run -p 80 --build-webhook-secret=githubtoken https://github.com/example/example Go to your GitHub repo, it should have the webhook configured to point to one of the webhook services. Webhook for Riofile \u00b6 Set up the webhook and private git clone secret for the git repository that contains Riofile: $ rio up --build-clone-secret gitsecret --build-webhook-secret webhook https://github.com/example/example For how to add the git and webhook secret, check here . Note: Riofile and Riofile-answers in the root directory are automatically applied.","title":"Webhooks"},{"location":"webhooks/#webhook","text":"By default, Rio will automatically poll the git repo and check if code has changed. You can also configure a webhook to automatically push any events to Rio to trigger the build. Note: Webhooks are currently only supported with Github. Set up the GitHub webhook token. $ rio secret add -- github - webhook Select namespace [ default ] : $ ( put the same namespace with your workload ) accessToken : $ ( github_accesstoken ) # the token has to be able create webhook in your github repo . Create workload and point to your repo . Create a workload and point to your repo rio run -p 80 --build-webhook-secret=githubtoken https://github.com/example/example Go to your GitHub repo, it should have the webhook configured to point to one of the webhook services.","title":"Webhook"},{"location":"webhooks/#webhook-for-riofile","text":"Set up the webhook and private git clone secret for the git repository that contains Riofile: $ rio up --build-clone-secret gitsecret --build-webhook-secret webhook https://github.com/example/example For how to add the git and webhook secret, check here . Note: Riofile and Riofile-answers in the root directory are automatically applied.","title":"Webhook for Riofile"},{"location":"workloads/","text":"Running workloads \u00b6 Deploying a Container Into Rio \u00b6 # Exposing the service requires passing the `-p` flag to expose ports from the container $ rio run -p 80 --name demo nginx # You will get an endpoint URL for your service $ rio ps # Access endpoint URL curl https://demo-v0-default.xxxxx.on-rio.io By default Rio will create a DNS record pointing to your cluster's gateway. Rio also uses Let's Encrypt to create a certificate for the cluster domain so that all services support HTTPS by default. For example, when you deploy your workload, you can access your workload in HTTPS. The domain always follows the format of ${app}-${namespace}.\\${cluster-domain}. You can see your cluster domain by running rio info . Note: Linkerd is enabled by default, so Rio will automatically inject linkerd-proxy into your workload. If you would like to disable that, run rio run --no-mesh . Expose your service \u00b6 Note: In order to expose your service you have to pass the flag --port (shorthand -p ). The format is [service_port:]container_port[/protocol] If you don't pass the flag, the service will be private by default (only accessible inside the cluster). # To expose services through 80/http $ rio run -p 80 /http nginx # To expose services through 80/http on port name web $ rio run -p 80 /http,web nginx # Do not expose service publicly $ rio run -p 80 ,web,expose = false nginx # To expose services through hostport 80 $ rio run -p 8080 :80,web,hostport = true nginx Examples \u00b6 Notes: - none of these examples have the port specified, so there will not be an available app endpoint - some of these examples need proper RBAC setup, for more information check here . # Running container with configMap mounted into containers, requires configMap to exist in the same namespace $ rio run --config config/nginx.conf:/etc/nginx/nginx.conf nginx # Running container with configMap mounted into containers, all keys from config will be mounted $ rio run --config config:/etc/nginx nginx # Running container with configMap as environment variable. $ rio run --env FOO = config://data/content nginx # Use configMap data and key content as value of environment variable FOO # Running container with secret mounted into containers, requires secret to exist in the same namespace $ rio run --secret certs/tls.crt:/etc/ssl/tls.key nginx # Running container with secret mounted into container, all keys from secret will be mounted $ rio run --secret certs:/etc/ssl/ nginx # Running container with secret as environment variable. $ rio run --env FOO = secret://certs/tls.crt nginx # Running container with no service mesh $ rio run --no-mesh nginx # Running container with privileged flag $ rio run --privileged nginx # Running container with environment variables $ rio run --env FOO = BAR --env FOO1 = BAR1 nginx # Running container and attach to it $ rio run -it nginx bash # Running container with scale of 5 $ rio run --scale = 5 nginx # Running container with host networking $ rio run --net = host nginx For more examples, check here Split Traffic Between Revisions \u00b6 Rio natively supports splitting traffic between revisions. Splitting Traffic can be quite useful in a canary deployment, a Blue/Green deployment and A/B testing. Each Rio service you deploy will have two unique label identifiers across current namespace: app and version . Based on app and version , the user is allowed to assign weight between each revision to manage traffic. To deploy a demo application with version v1 # Names follow the format of [namespace:]app[@version]. Defaults to default namespace and v0 version. $ rio run --name demo@v1 -p 80 ibuildthecloud/demo:v1 To deploy another version with version v3 # Create a new service associated to the demo app, with different desired version and image, and give it a weight of zero $ rio stage --image ibuildthecloud/demo:v3 demo@v1 v3 # Manually stage using run $ rio run --name demo@v3 --ports 80 --weight 0 ibuildthecloud/demo:v3 Now you have defined two services with app demo and versions v1 and v3 . To access the global endpoint that serves traffic from both versions: # Endpoint URL always follows the format of `${app}-${namespace}.xxxxxx.on-rio.io` $ rio endpoints NAME ENDPOINTS demo https://demo-default.xxxxxx.on-rio.io Note: This endpoint will only return versions that have a weight greater than 0%. Versions with a higher weight percentage will be returned more often. Assign weight between each revision \u00b6 Now assign a weight of 50% to demo@v3 # Weight is immediately assigned by default $ rio weight demo@v3 = 50 % # Gradually increase weight over the specified duration (s=seconds, m=minutes, h=hours) $ rio weight --duration 10m demo@v3 = 50 % # Promote v3 service (assigns weight=100% and sets all other versions to weight = 0%) $ rio promote demo@v3 Note: services are discoverable inside the cluster by their short DNS name. For example services demo@v1 and demo@v3 are discoverable through demo-v1 and demo-v3 . demo is also discoverable to serve traffic from both versions. Running Stateful Applications (experimental) \u00b6 Rio supports running stateful applications by leveraging Kubernetes' persistentvolume . To mount a volume into a container (By default it will create an emptydir volume): $ rio run -v foo:/data nginx To mount a persistent volume into a container (By default it will create a persistent volume if the cluster has a default storageclass, otherwise it will use the existing pvc with the same name): $ rio run -v foo:/data,persistent = true nginx To mount a hostpath volume into a container $ rio run -v foo:/etc,hosttype = directoryorcreate nginx Note: hostpath type can be found in here","title":"Running workloads"},{"location":"workloads/#running-workloads","text":"","title":"Running workloads"},{"location":"workloads/#deploying-a-container-into-rio","text":"# Exposing the service requires passing the `-p` flag to expose ports from the container $ rio run -p 80 --name demo nginx # You will get an endpoint URL for your service $ rio ps # Access endpoint URL curl https://demo-v0-default.xxxxx.on-rio.io By default Rio will create a DNS record pointing to your cluster's gateway. Rio also uses Let's Encrypt to create a certificate for the cluster domain so that all services support HTTPS by default. For example, when you deploy your workload, you can access your workload in HTTPS. The domain always follows the format of ${app}-${namespace}.\\${cluster-domain}. You can see your cluster domain by running rio info . Note: Linkerd is enabled by default, so Rio will automatically inject linkerd-proxy into your workload. If you would like to disable that, run rio run --no-mesh .","title":"Deploying a Container Into Rio"},{"location":"workloads/#expose-your-service","text":"Note: In order to expose your service you have to pass the flag --port (shorthand -p ). The format is [service_port:]container_port[/protocol] If you don't pass the flag, the service will be private by default (only accessible inside the cluster). # To expose services through 80/http $ rio run -p 80 /http nginx # To expose services through 80/http on port name web $ rio run -p 80 /http,web nginx # Do not expose service publicly $ rio run -p 80 ,web,expose = false nginx # To expose services through hostport 80 $ rio run -p 8080 :80,web,hostport = true nginx","title":"Expose your service"},{"location":"workloads/#examples","text":"Notes: - none of these examples have the port specified, so there will not be an available app endpoint - some of these examples need proper RBAC setup, for more information check here . # Running container with configMap mounted into containers, requires configMap to exist in the same namespace $ rio run --config config/nginx.conf:/etc/nginx/nginx.conf nginx # Running container with configMap mounted into containers, all keys from config will be mounted $ rio run --config config:/etc/nginx nginx # Running container with configMap as environment variable. $ rio run --env FOO = config://data/content nginx # Use configMap data and key content as value of environment variable FOO # Running container with secret mounted into containers, requires secret to exist in the same namespace $ rio run --secret certs/tls.crt:/etc/ssl/tls.key nginx # Running container with secret mounted into container, all keys from secret will be mounted $ rio run --secret certs:/etc/ssl/ nginx # Running container with secret as environment variable. $ rio run --env FOO = secret://certs/tls.crt nginx # Running container with no service mesh $ rio run --no-mesh nginx # Running container with privileged flag $ rio run --privileged nginx # Running container with environment variables $ rio run --env FOO = BAR --env FOO1 = BAR1 nginx # Running container and attach to it $ rio run -it nginx bash # Running container with scale of 5 $ rio run --scale = 5 nginx # Running container with host networking $ rio run --net = host nginx For more examples, check here","title":"Examples"},{"location":"workloads/#split-traffic-between-revisions","text":"Rio natively supports splitting traffic between revisions. Splitting Traffic can be quite useful in a canary deployment, a Blue/Green deployment and A/B testing. Each Rio service you deploy will have two unique label identifiers across current namespace: app and version . Based on app and version , the user is allowed to assign weight between each revision to manage traffic. To deploy a demo application with version v1 # Names follow the format of [namespace:]app[@version]. Defaults to default namespace and v0 version. $ rio run --name demo@v1 -p 80 ibuildthecloud/demo:v1 To deploy another version with version v3 # Create a new service associated to the demo app, with different desired version and image, and give it a weight of zero $ rio stage --image ibuildthecloud/demo:v3 demo@v1 v3 # Manually stage using run $ rio run --name demo@v3 --ports 80 --weight 0 ibuildthecloud/demo:v3 Now you have defined two services with app demo and versions v1 and v3 . To access the global endpoint that serves traffic from both versions: # Endpoint URL always follows the format of `${app}-${namespace}.xxxxxx.on-rio.io` $ rio endpoints NAME ENDPOINTS demo https://demo-default.xxxxxx.on-rio.io Note: This endpoint will only return versions that have a weight greater than 0%. Versions with a higher weight percentage will be returned more often.","title":"Split Traffic Between Revisions"},{"location":"workloads/#assign-weight-between-each-revision","text":"Now assign a weight of 50% to demo@v3 # Weight is immediately assigned by default $ rio weight demo@v3 = 50 % # Gradually increase weight over the specified duration (s=seconds, m=minutes, h=hours) $ rio weight --duration 10m demo@v3 = 50 % # Promote v3 service (assigns weight=100% and sets all other versions to weight = 0%) $ rio promote demo@v3 Note: services are discoverable inside the cluster by their short DNS name. For example services demo@v1 and demo@v3 are discoverable through demo-v1 and demo-v3 . demo is also discoverable to serve traffic from both versions.","title":"Assign weight between each revision"},{"location":"workloads/#running-stateful-applications-experimental","text":"Rio supports running stateful applications by leveraging Kubernetes' persistentvolume . To mount a volume into a container (By default it will create an emptydir volume): $ rio run -v foo:/data nginx To mount a persistent volume into a container (By default it will create a persistent volume if the cluster has a default storageclass, otherwise it will use the existing pvc with the same name): $ rio run -v foo:/data,persistent = true nginx To mount a hostpath volume into a container $ rio run -v foo:/etc,hosttype = directoryorcreate nginx Note: hostpath type can be found in here","title":"Running Stateful Applications (experimental)"}]}